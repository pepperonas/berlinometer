<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio BPM Counter</title>
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #2C2E3B;
            color: #ffffff;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            align-items: center;
            justify-content: center;
        }

        .container {
            width: 100%;
            max-width: 600px;
            background-color: #3C3F54;
            border-radius: 8px;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
            padding: 30px;
            text-align: center;
        }

        h1 {
            margin-top: 0;
            font-weight: 400;
            color: #ffffff;
        }

        .bpm-display {
            font-size: 72px;
            font-weight: 300;
            margin: 20px 0;
            color: #ffffff;
        }

        .visualizer {
            width: 100%;
            height: 150px;
            background-color: #2C2E3B;
            margin: 20px 0;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .beat-indicator {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(121, 134, 203, 0.3);
            opacity: 0;
            transition: opacity 0.1s;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }

        .control-button {
            background-color: #546E7A;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .control-button:hover {
            background-color: #455A64;
        }

        .control-button.primary {
            background-color: #7986CB;
        }

        .control-button.primary:hover {
            background-color: #5C6BC0;
        }

        .average-display {
            margin-top: 15px;
            font-size: 16px;
            color: #B0BEC5;
        }

        .status {
            margin-top: 15px;
            font-size: 14px;
            color: #90A4AE;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        .sensitivity-control {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 20px;
            gap: 10px;
        }

        .sensitivity-control label {
            font-size: 14px;
            color: #B0BEC5;
        }

        .sensitivity-control input {
            width: 150px;
        }

        .bands-display {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
            padding: 5px;
            background-color: #2C2E3B;
            border-radius: 4px;
        }

        .band {
            height: 10px;
            width: 20%;
            margin: 0 2px;
            background-color: #5C6BC0;
            border-radius: 2px;
            transition: height 0.1s ease-out;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Audio BPM Counter</h1>
    <div class="bpm-display" id="bpmDisplay">0</div>

    <div class="visualizer">
        <canvas id="audioVisualizer"></canvas>
        <div class="beat-indicator" id="beatIndicator"></div>
    </div>

    <div class="bands-display" id="bandsDisplay">
        <div class="band" id="band0"></div>
        <div class="band" id="band1"></div>
        <div class="band" id="band2"></div>
        <div class="band" id="band3"></div>
    </div>

    <div class="sensitivity-control">
        <label for="sensitivitySlider">Empfindlichkeit:</label>
        <input type="range" id="sensitivitySlider" min="1" max="30" value="15">
    </div>

    <div class="average-display" id="averageDisplay">Durchschnitt: 0 BPM</div>
    <div class="status" id="statusText">Klicke auf Start, um das Mikrofon zu aktivieren</div>

    <div class="controls">
        <button class="control-button primary" id="startButton">Start</button>
        <button class="control-button" id="resetButton">Zurücksetzen</button>
        <button class="control-button" id="averageButton">Durchschnitt</button>
    </div>
</div>

<script>
    /**
     * BPM-Erkennungs-Engine mit Frequenzanalyse
     */
    class BPMAnalyzer {
        constructor(options = {}) {
            // Konfiguration
            this.sampleRate = options.sampleRate || 44100;
            this.minBPM = options.minBPM || 60;
            this.maxBPM = options.maxBPM || 180;
            this.bufferSize = options.bufferSize || 2048;
            this.hopSize = options.hopSize || 441; // ca. 10ms bei 44.1kHz
            this.historySize = options.historySize || 20; // Anzahl der Beats zum Speichern

            // Frequenzbänder für die Analyse
            this.bands = [
                {low: 20, high: 60},    // Subbass
                {low: 60, high: 200},   // Bass
                {low: 200, high: 600},  // Low-Mids
                {low: 600, high: 2000}  // Mids
            ];

            // Zustandsmanagement
            this.energyHistory = this.bands.map(() => []);
            this.beatHistory = [];
            this.tempoQueue = [];
            this.lastBeatTime = 0;
            this.frameCount = 0;

            // Schwellwerte
            this.beatSensitivity = options.sensitivity || 1.5;
            this.beatDecay = options.decay || 0.99;
            this.energyThreshold = 0.8;

            // Für die Beat-Visualisierung
            this.currentBandEnergies = [0, 0, 0, 0];
            this.lastBeatDetection = null;
            this.hasNewBeat = false;
        }

        /**
         * Analysiert das Frequenzspektrum basierend auf den FFT-Daten
         * @param {Uint8Array} fftData - Frequenzdaten vom Analyzer-Node
         * @returns {Array} - Energie in jedem Frequenzband
         */
        analyzeSpectrum(fftData) {
            const binSize = this.sampleRate / (fftData.length * 2); // Berechnung der Frequenzauflösung
            const bandEnergies = [];

            for (const band of this.bands) {
                const lowBin = Math.floor(band.low / binSize);
                const highBin = Math.min(Math.ceil(band.high / binSize), fftData.length - 1);

                let energy = 0;
                for (let i = lowBin; i <= highBin; i++) {
                    // Normalisieren der Werte (0-255 zu 0-1)
                    const normalizedValue = fftData[i] / 255;
                    energy += normalizedValue * normalizedValue; // Quadrierte Magnitude
                }

                // Normalisieren
                energy = Math.sqrt(energy / (highBin - lowBin + 1));
                bandEnergies.push(energy);
            }

            this.currentBandEnergies = bandEnergies;
            return bandEnergies;
        }

        /**
         * Erkennt Beats basierend auf Energieveränderungen
         * @param {Array} bandEnergies - Energie in jedem Frequenzband
         * @returns {Array} - Erkannte Beats
         */
        detectBeats(bandEnergies) {
            const beats = [];
            this.hasNewBeat = false;

            // Energieschwankungen analysieren
            for (let i = 0; i < this.bands.length; i++) {
                const energy = bandEnergies[i];
                const history = this.energyHistory[i];

                // Initialisieren der Historiewerte
                if (history.length < 5) {
                    history.push(energy);
                    continue;
                }

                // Gleitender Durchschnitt der letzten Energiewerte
                const avgEnergy = history.reduce((sum, val) => sum + val, 0) / history.length;

                // Standardabweichung berechnen
                const variance = history.reduce((sum, val) => sum + Math.pow(val - avgEnergy, 2), 0) / history.length;
                const stdDev = Math.sqrt(variance);

                // Beat-Erkennung: Aktuelle Energie muss signifikant höher sein als der Durchschnitt
                const threshold = avgEnergy + this.beatSensitivity * stdDev;

                // Zeitlicher Abstand zum letzten Beat
                const currentTime = this.frameCount * (this.hopSize / this.sampleRate);
                const timeSinceLastBeat = currentTime - this.lastBeatTime;
                const minBeatInterval = 60 / this.maxBPM; // Minimaler Abstand zwischen Beats

                if (energy > threshold && energy > this.energyThreshold && timeSinceLastBeat >= minBeatInterval) {
                    beats.push({
                        time: currentTime,
                        band: i,
                        energy: energy
                    });

                    this.lastBeatTime = currentTime;
                    this.lastBeatDetection = {time: new Date().getTime(), energy: energy, band: i};
                    this.hasNewBeat = true;
                }

                // Verlauf aktualisieren (FIFO)
                history.push(energy);
                if (history.length > 20) {
                    history.shift();
                }
            }

            this.frameCount++;
            return beats;
        }

        /**
         * Verarbeitet ein neues Audio-Frame
         * @param {Uint8Array} fftData - Frequenzdaten vom Analyzer-Node
         * @returns {Object} - Erkennungsergebnisse mit BPM und Beat-Info
         */
        processFrame(fftData) {
            // Spektrumanalyse
            const bandEnergies = this.analyzeSpectrum(fftData);

            // Beat-Erkennung
            const beats = this.detectBeats(bandEnergies);

            // Beat-Historie aktualisieren
            if (beats.length > 0) {
                // Nur den stärksten Beat verwenden
                const strongestBeat = beats.reduce(
                    (strongest, beat) => beat.energy > strongest.energy ? beat : strongest,
                    beats[0]
                );

                // Zeit zwischen Beats für BPM-Berechnung
                const now = new Date().getTime();
                if (this.beatHistory.length > 0) {
                    const lastBeat = this.beatHistory[this.beatHistory.length - 1];
                    const timeDiff = now - lastBeat.timestamp;

                    // BPM berechnen (60000 ms / Zeit zwischen Beats)
                    if (timeDiff > 150) { // Ignoriere zu schnelle Beats
                        const instantBPM = Math.round(60000 / timeDiff);
                        if (instantBPM >= this.minBPM && instantBPM <= this.maxBPM) {
                            this.tempoQueue.push(instantBPM);
                            if (this.tempoQueue.length > 10) {
                                this.tempoQueue.shift();
                            }
                        }
                    }
                }

                // Beat zur Historie hinzufügen
                this.beatHistory.push({
                    timestamp: now,
                    band: strongestBeat.band,
                    energy: strongestBeat.energy
                });

                // Historiegröße begrenzen
                if (this.beatHistory.length > this.historySize) {
                    this.beatHistory.shift();
                }
            }

            return {
                bpm: this.getCurrentBPM(),
                beatDetected: this.hasNewBeat,
                lastBeat: this.lastBeatDetection,
                bandEnergies: this.currentBandEnergies
            };
        }

        /**
         * Berechnet den aktuellen BPM-Wert
         * @returns {number|null} - BPM-Wert oder null, wenn nicht genug Daten
         */
        getCurrentBPM() {
            if (this.tempoQueue.length < 2) {
                return null;
            }

            // Sortieren für Medianberechnung
            const sorted = [...this.tempoQueue].sort((a, b) => a - b);

            // Ausreißer entfernen (obere und untere 20%)
            const cutoff = Math.floor(sorted.length * 0.2);
            let filtered = sorted;
            if (sorted.length >= 5) {
                filtered = sorted.slice(cutoff, sorted.length - cutoff);
            }

            // Median für stabilere Ergebnisse
            const mid = Math.floor(filtered.length / 2);
            let bpm;
            if (filtered.length % 2 === 0) {
                bpm = (filtered[mid - 1] + filtered[mid]) / 2;
            } else {
                bpm = filtered[mid];
            }

            // BPM in gültigen Bereich bringen
            return this._constrainBPM(bpm);
        }

        /**
         * Stellt sicher, dass das BPM im gültigen Bereich liegt
         * @param {number} bpm - BPM-Wert
         * @returns {number|null} - Korrigierter BPM-Wert
         */
        _constrainBPM(bpm) {
            if (!bpm) return null;

            // Innerhalb der min/max Grenzen halten
            bpm = Math.max(this.minBPM, Math.min(this.maxBPM, bpm));

            // Oktavfehler korrigieren (z.B. wenn das System die halbe oder doppelte Rate erkennt)
            if (bpm < 65) {
                bpm *= 2; // Zu langsam, verdoppeln
            } else if (bpm > 160) {
                bpm /= 2; // Zu schnell, halbieren
            }

            // Auf eine Dezimalstelle runden
            return Math.round(bpm);
        }

        /**
         * Aktualisiert die Empfindlichkeit des Beat-Detektors
         * @param {number} sensitivity - Neue Empfindlichkeit
         */
        setSensitivity(sensitivity) {
            this.beatSensitivity = sensitivity;
        }

        /**
         * Setzt alle gespeicherten Daten zurück
         */
        reset() {
            this.energyHistory = this.bands.map(() => []);
            this.beatHistory = [];
            this.tempoQueue = [];
            this.lastBeatTime = 0;
            this.frameCount = 0;
            this.lastBeatDetection = null;
            this.hasNewBeat = false;
        }
    }

    document.addEventListener('DOMContentLoaded', function () {
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');
        const averageButton = document.getElementById('averageButton');
        const bpmDisplay = document.getElementById('bpmDisplay');
        const averageDisplay = document.getElementById('averageDisplay');
        const statusText = document.getElementById('statusText');
        const beatIndicator = document.getElementById('beatIndicator');
        const sensitivitySlider = document.getElementById('sensitivitySlider');
        const canvas = document.getElementById('audioVisualizer');
        const canvasCtx = canvas.getContext('2d');

        // Band-Anzeigen
        const bandElements = [
            document.getElementById('band0'),
            document.getElementById('band1'),
            document.getElementById('band2'),
            document.getElementById('band3')
        ];

        let audioContext;
        let analyser;
        let microphone;
        let javascriptNode;
        let isInitialized = false;
        let isRunning = false;
        let bpmAnalyzer;

        let bpmReadings = [];
        let isCalculatingAverage = false;
        let beatEnergy = 0;

        // Einstellungen für die Visualisierung
        let dataArray;
        let bufferLength;

        // Audio-Kontext initialisieren und Mikrofon anfordern
        async function initAudio() {
            try {
                if (!isInitialized) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    // BPM-Analyzer initialisieren
                    bpmAnalyzer = new BPMAnalyzer({
                        sampleRate: audioContext.sampleRate,
                        minBPM: 60,
                        maxBPM: 200,
                        sensitivity: sensitivitySlider.value / 10
                    });

                    // Mikrofon-Zugriff anfordern
                    const stream = await navigator.mediaDevices.getUserMedia({audio: true});

                    // Audio-Nodes einrichten
                    microphone = audioContext.createMediaStreamSource(stream);
                    analyser = audioContext.createAnalyser();

                    // Verbindungen herstellen
                    microphone.connect(analyser);

                    // Analyser-Einstellungen
                    analyser.fftSize = 2048;
                    bufferLength = analyser.frequencyBinCount;
                    dataArray = new Uint8Array(bufferLength);

                    // JavaScript-Prozessor für die Echtzeit-Analyse
                    javascriptNode = audioContext.createScriptProcessor(2048, 1, 1);
                    analyser.connect(javascriptNode);
                    javascriptNode.connect(audioContext.destination);

                    // Event-Handler für die Audio-Verarbeitung
                    javascriptNode.onaudioprocess = processAudio;

                    isInitialized = true;
                    isRunning = true;

                    // UI aktualisieren
                    startButton.textContent = "Stopp";
                    statusText.textContent = "Lausche auf Beats...";

                    // Visualisierung starten
                    drawVisualizer();
                } else {
                    // Wenn bereits initialisiert, nur den Status umschalten
                    toggleRunning();
                }
            } catch (error) {
                console.error("Fehler beim Zugriff auf das Mikrofon:", error);
                statusText.textContent = "Fehler: Mikrofon nicht verfügbar. Bitte erlaube den Zugriff.";
            }
        }

        // Audio-Verarbeitung
        function processAudio(event) {
            if (!isRunning) return;

            // Frequenzdaten abrufen
            analyser.getByteFrequencyData(dataArray);

            // BPM-Analyse durchführen
            const result = bpmAnalyzer.processFrame(dataArray);

            // Aktualisiere Bandenergien in der UI
            updateBandDisplay(result.bandEnergies);

            // Beat-Anzeige aktualisieren
            if (result.beatDetected) {
                const beatStrength = result.lastBeat.energy;
                beatIndicator.style.opacity = Math.min(beatStrength * 1.5, 1);
                setTimeout(() => {
                    beatIndicator.style.opacity = "0";
                }, 100);

                beatEnergy = beatStrength;
            }

            // BPM anzeigen, wenn verfügbar
            if (result.bpm !== null) {
                bpmDisplay.textContent = result.bpm;

                // Wenn wir den Durchschnitt berechnen, füge den aktuellen BPM hinzu
                if (isCalculatingAverage) {
                    bpmReadings.push(result.bpm);
                    updateAverageDisplay();
                }
            }
        }

        // Aktualisiert die Band-Anzeige
        function updateBandDisplay(bandEnergies) {
            for (let i = 0; i < bandEnergies.length; i++) {
                const energy = bandEnergies[i];
                const height = Math.min(energy * 50, 30); // Max. Höhe von 30px
                bandElements[i].style.height = `${height}px`;

                // Farbe basierend auf Energie
                const hue = 240 - (energy * 120); // Blau → Rot
                bandElements[i].style.backgroundColor = `hsl(${hue}, 80%, 60%)`;
            }
        }

        // Visualisierung zeichnen
        function drawVisualizer() {
            if (!isInitialized) return;

            requestAnimationFrame(drawVisualizer);

            // Canvas-Größe anpassen
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;

            // Hintergrund löschen
            canvasCtx.fillStyle = '#2C2E3B';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

            // Audiodaten abrufen
            analyser.getByteFrequencyData(dataArray);

            // Zeichne verbesserte Visualisierung mit Fokus auf Bassfrequenzen
            const barWidth = Math.max(4, canvas.width / 64);
            const gap = 1;
            let x = 0;

            // Nur die niedrigeren Frequenzen anzeigen (mehr Details wo die Beats sind)
            const numBars = Math.min(64, bufferLength);

            for (let i = 0; i < numBars; i++) {
                // Nicht-lineare Skalierung für bessere Visualisierung von Bass
                let index = Math.floor(i * i / 20);
                index = Math.min(index, bufferLength - 1);

                let value = dataArray[index];

                // Höhere Skalierung für niedrigere Frequenzen (Bass betonen)
                let multiplier = 1.0;
                if (i < 10) {
                    multiplier = 1.5;  // Bass-Frequenzen hervorheben
                }

                const barHeight = (value / 255) * canvas.height * multiplier;

                // Farbverlauf mit mehr Kontrast und Helligkeit
                const hue = 240 - (i / numBars * 60); // Blautöne
                const saturation = 80 + (value / 255 * 20); // Mehr Sättigung bei höherem Wert
                const lightness = 50 + (value / 255 * 30); // Hellere Farben bei höherem Wert

                canvasCtx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                canvasCtx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);

                // Hinzufügen einer Kontur (optional)
                if (barHeight > canvas.height * 0.5) {
                    canvasCtx.strokeStyle = '#ffffff';
                    canvasCtx.lineWidth = 1;
                    canvasCtx.strokeRect(x, canvas.height - barHeight, barWidth, barHeight);
                }

                x += barWidth + gap;
            }

            // Zeichne Beat-Energie-Indikator
            if (beatEnergy > 0) {
                const circleRadius = beatEnergy * 50;

                canvasCtx.beginPath();
                canvasCtx.arc(canvas.width / 2, canvas.height / 2, circleRadius, 0, Math.PI * 2);
                canvasCtx.fillStyle = `rgba(255, 255, 255, 0.2)`;
                canvasCtx.fill();

                beatEnergy *= 0.95; // Langsames Ausblenden
            }
        }

        // Durchschnitt anzeigen
        function updateAverageDisplay() {
            if (bpmReadings.length === 0) {
                averageDisplay.textContent = "Durchschnitt: 0 BPM";
                return;
            }

            const averageBPM = Math.round(bpmReadings.reduce((a, b) => a + b, 0) / bpmReadings.length);
            averageDisplay.textContent = `Durchschnitt: ${averageBPM} BPM (${bpmReadings.length} Beats)`;
        }

        // Alles zurücksetzen
        function resetCounter() {
            if (bpmAnalyzer) {
                bpmAnalyzer.reset();
            }

            bpmDisplay.textContent = "0";
            isCalculatingAverage = false;
            bpmReadings = [];
            averageDisplay.textContent = "Durchschnitt: 0 BPM";
            averageButton.textContent = "Durchschnitt";
            beatEnergy = 0;
        }

        // Durchschnittsberechnung ein-/ausschalten
        function toggleAverageCalculation() {
            isCalculatingAverage = !isCalculatingAverage;

            if (isCalculatingAverage) {
                bpmReadings = [];
                averageButton.textContent = "Stopp";
                updateAverageDisplay();
            } else {
                averageButton.textContent = "Durchschnitt";
            }
        }

        // Laufenden Status umschalten
        function toggleRunning() {
            isRunning = !isRunning;

            if (isRunning) {
                startButton.textContent = "Stopp";
                statusText.textContent = "Lausche auf Beats...";
            } else {
                startButton.textContent = "Start";
                statusText.textContent = "Pausiert";
            }
        }

        // Empfindlichkeit aktualisieren
        sensitivitySlider.addEventListener('input', function () {
            if (bpmAnalyzer) {
                bpmAnalyzer.setSensitivity(sensitivitySlider.value / 10);
            }
        });

        // Event-Listener
        startButton.addEventListener('click', initAudio);
        resetButton.addEventListener('click', resetCounter);
        averageButton.addEventListener('click', toggleAverageCalculation);
    });
</script>
</body>
</html>