<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web-Shot - Kamera Web-App | Fotos direkt im Browser aufnehmen</title>
    
    <!-- Primary Meta Tags -->
    <meta name="title" content="Web-Shot - Kamera Web-App | Fotos direkt im Browser aufnehmen">
    <meta name="description" content="Kostenlose Kamera-Web-App zum Aufnehmen, Speichern und Herunterladen von Fotos direkt im Browser. Keine Installation erforderlich - funktioniert auf allen Ger√§ten mit Kamera.">
    <meta name="keywords" content="kamera app, web kamera, foto aufnehmen, browser kamera, online foto, webcam capture, foto tool, kostenlose kamera app">
    <meta name="author" content="mrx3k1.de">
    <meta name="language" content="de">
    <meta name="robots" content="index, follow">
    
    <!-- Open Graph / Facebook / WhatsApp -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://mrx3k1.de/web-shot/">
    <meta property="og:title" content="Web-Shot - Kamera Web-App | Fotos direkt im Browser aufnehmen">
    <meta property="og:description" content="Kostenlose Kamera-Web-App zum Aufnehmen von Fotos direkt im Browser. Keine Installation erforderlich.">
    <meta property="og:image" content="https://mrx3k1.de/web-shot/og-image.jpg?v=1">
    <meta property="og:image:secure_url" content="https://mrx3k1.de/web-shot/og-image.jpg?v=1">
    <meta property="og:image:type" content="image/jpeg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:image:alt" content="Web-Shot Kamera App Screenshot">
    <meta property="og:locale" content="de_DE">
    <meta property="og:site_name" content="mrx3k1.de">
    
    <!-- WhatsApp specific -->
    <meta property="og:image:url" content="https://mrx3k1.de/web-shot/og-image.jpg?v=1">
    <link rel="image_src" href="https://mrx3k1.de/web-shot/og-image.jpg?v=1">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://mrx3k1.de/web-shot/">
    <meta property="twitter:title" content="Web-Shot - Kamera Web-App">
    <meta property="twitter:description" content="Fotos direkt im Browser aufnehmen - kostenlos und ohne Installation.">
    <meta property="twitter:image" content="https://mrx3k1.de/web-shot/twitter-image.jpg">
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="apple-touch-icon" href="favicon-32x32.png">
    
    <!-- Schema.org for Google -->
    <meta itemprop="name" content="Web-Shot - Kamera Web-App">
    <meta itemprop="description" content="Kostenlose Kamera-Web-App zum Aufnehmen von Fotos direkt im Browser">
    <meta itemprop="image" content="https://mrx3k1.de/web-shot/og-image.jpg">
    
    <!-- Additional Meta Tags -->
    <meta name="theme-color" content="#688db1">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="application-name" content="Web-Shot">
    <meta name="msapplication-TileColor" content="#2B2E3B">
    <meta name="format-detection" content="telephone=no">
    
    <!-- MediaPipe for background segmentation -->
    <!-- MediaPipe with specific working versions -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1632432234/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils@0.6.1629159505/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation@0.1.1632777926/selfie_segmentation.js" crossorigin="anonymous"></script>
    
    <style>
        :root {
            --background-dark: #2B2E3B;
            --background-darker: #252830;
            --card-background: #343845;
            --accent-blue: #688db1;
            --accent-green: #9cb68f;
            --accent-red: #e16162;
            --text-primary: #d1d5db;
            --text-secondary: #9ca3af;

            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.1);

            --radius-sm: 0.5rem;
            --radius: 0.75rem;
            --radius-lg: 1rem;
            --radius-xl: 1.5rem;

            --spacing-2: 0.5rem;
            --spacing-4: 1rem;
            --spacing-6: 1.5rem;
            --spacing-8: 2rem;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
            'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
            sans-serif;
            background: var(--background-dark);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: var(--spacing-4);
        }

        .header {
            text-align: center;
            margin-bottom: var(--spacing-8);
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--accent-blue);
            margin-bottom: var(--spacing-2);
        }

        .subtitle {
            font-size: 1.125rem;
            color: var(--text-secondary);
        }

        .camera-section {
            background: var(--card-background);
            border-radius: var(--radius-lg);
            padding: var(--spacing-6);
            box-shadow: var(--shadow-lg);
            margin-bottom: var(--spacing-6);
        }

        .video-container {
            position: relative;
            text-align: center;
            margin-bottom: var(--spacing-6);
            width: 100%;
            max-width: 640px;
            margin-left: auto;
            margin-right: auto;
            padding: 0 var(--spacing-4);
        }

        @media (max-width: 768px) {
            .video-container {
                padding: 0 var(--spacing-2);
                max-width: 100%;
            }
        }

        #video {
            width: 100%;
            max-width: 640px;
            height: auto;
            border-radius: var(--radius);
            background: var(--background-darker);
        }

        .controls {
            display: flex;
            gap: var(--spacing-4);
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: var(--spacing-6);
        }

        @media (max-width: 768px) {
            .controls {
                gap: var(--spacing-2);
                padding: 0 var(--spacing-2);
            }
        }

        .btn {
            padding: 0.875rem 2rem;
            border: none;
            border-radius: var(--radius);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: var(--accent-blue);
            color: white;
        }

        .btn-primary:hover {
            background: #5a7a9a;
            transform: translateY(-1px);
            box-shadow: var(--shadow);
        }

        .btn-secondary {
            background: var(--accent-green);
            color: white;
        }

        .btn-secondary:hover {
            background: #8ba580;
            transform: translateY(-1px);
            box-shadow: var(--shadow);
        }

        .btn-danger {
            background: var(--accent-red);
            color: white;
        }

        .btn-danger:hover {
            background: #d14545;
            transform: translateY(-1px);
            box-shadow: var(--shadow);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .photos-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: var(--spacing-4);
            margin-top: var(--spacing-6);
        }

        .photo-item {
            background: var(--card-background);
            border-radius: var(--radius);
            padding: var(--spacing-4);
            text-align: center;
            transition: transform 0.3s ease;
        }

        .photo-item:hover {
            transform: translateY(-2px);
        }

        .photo-item img {
            width: 100%;
            height: 120px;
            object-fit: cover;
            border-radius: var(--radius-sm);
            margin-bottom: var(--spacing-2);
        }

        .photo-item .timestamp {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: var(--spacing-2);
        }

        .status {
            text-align: center;
            padding: var(--spacing-4);
            border-radius: var(--radius);
            margin-bottom: var(--spacing-4);
            font-weight: 500;
        }

        .status.success {
            background: rgba(156, 182, 143, 0.2);
            color: var(--accent-green);
            border: 1px solid var(--accent-green);
        }

        .status.error {
            background: rgba(225, 97, 98, 0.2);
            color: var(--accent-red);
            border: 1px solid var(--accent-red);
        }

        .hidden {
            display: none;
        }

        #canvas {
            display: block;
            width: 100%;
            max-width: 640px;
            height: auto;
            border-radius: var(--radius);
            margin: 0 auto;
            position: relative;
        }

        #canvas.hidden {
            display: none;
        }

        .filter-section {
            background: var(--card-background);
            border-radius: var(--radius-lg);
            padding: var(--spacing-6);
            box-shadow: var(--shadow-lg);
            margin-bottom: var(--spacing-6);
        }

        .filter-presets {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: var(--spacing-2);
            margin-bottom: var(--spacing-4);
        }

        @media (max-width: 768px) {
            .filter-presets {
                grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
                gap: var(--spacing-2);
                padding: 0 var(--spacing-2);
            }
        }

        .filter-preset {
            background: var(--background-darker);
            border: 2px solid transparent;
            border-radius: var(--radius);
            padding: var(--spacing-2);
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.875rem;
        }

        .filter-preset:hover {
            border-color: var(--accent-blue);
            transform: translateY(-1px);
        }

        .filter-preset.active {
            border-color: var(--accent-green);
            background: rgba(156, 182, 143, 0.2);
        }

        .filter-controls {
            margin-top: var(--spacing-4);
            display: grid;
            gap: var(--spacing-4);
            grid-template-columns: 1fr;
        }

        /* Desktop: 2-column layout for compact GUI */
        @media (min-width: 769px) {
            .filter-controls {
                grid-template-columns: 1fr 1fr;
                gap: var(--spacing-4) var(--spacing-6);
            }
        }

        /* Mobile: single column with better spacing */
        @media (max-width: 768px) {
            .filter-controls {
                gap: var(--spacing-5);
                padding: 0 var(--spacing-2);
            }
        }

        .filter-control {
            margin-bottom: var(--spacing-4);
        }

        .filter-control label {
            display: block;
            margin-bottom: var(--spacing-2);
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .filter-slider {
            width: 100%;
            height: 6px;
            background: var(--background-darker);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .filter-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent-blue);
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .filter-slider::-webkit-slider-thumb:hover {
            background: #5a7a9a;
        }

        .filter-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--accent-blue);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        /* Mobile: Larger touch targets for sliders */
        @media (max-width: 768px) {
            .filter-slider {
                height: 10px;
                margin: var(--spacing-3) 0;
            }
            
            .filter-slider::-webkit-slider-thumb {
                width: 26px;
                height: 26px;
            }
            
            .filter-slider::-moz-range-thumb {
                width: 26px;
                height: 26px;
            }
            
            .filter-control {
                margin-bottom: var(--spacing-5);
            }
            
            .filter-control label {
                font-size: 1rem;
                margin-bottom: var(--spacing-2);
                display: block;
            }
        }

        .filter-value {
            display: inline-block;
            margin-left: var(--spacing-2);
            color: var(--accent-blue);
            font-weight: 600;
            min-width: 40px;
        }

        .background-section {
            background: var(--card-background);
            border-radius: var(--radius-lg);
            padding: var(--spacing-6);
            box-shadow: var(--shadow-lg);
            margin-bottom: var(--spacing-6);
        }

        .background-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: var(--spacing-4);
            margin-bottom: var(--spacing-4);
        }

        @media (max-width: 768px) {
            .background-options {
                grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
                gap: var(--spacing-2);
                padding: 0 var(--spacing-2);
            }
        }

        .background-option {
            background: var(--background-darker);
            border: 2px solid transparent;
            border-radius: var(--radius);
            padding: var(--spacing-4);
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .background-option:hover {
            border-color: var(--accent-blue);
            transform: translateY(-2px);
        }

        .background-option.active {
            border-color: var(--accent-green);
            background: rgba(156, 182, 143, 0.2);
        }

        .background-option-icon {
            font-size: 2rem;
            margin-bottom: var(--spacing-2);
        }

        .upload-section {
            margin-top: var(--spacing-4);
            padding: var(--spacing-4);
            background: var(--background-darker);
            border-radius: var(--radius);
            text-align: center;
        }

        #backgroundUpload {
            display: none;
        }

        .upload-btn {
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-2);
            padding: 0.75rem 1.5rem;
            background: var(--accent-blue);
            color: white;
            border: none;
            border-radius: var(--radius);
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .upload-btn:hover {
            background: #5a7a9a;
            transform: translateY(-1px);
        }

        .background-presets {
            margin-bottom: var(--spacing-4);
        }

        .preset-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: var(--spacing-3);
            margin-bottom: var(--spacing-4);
        }

        .preset-item {
            background: var(--surface);
            border-radius: var(--radius);
            padding: var(--spacing-2);
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .preset-item:hover {
            background: var(--surface-hover);
            transform: translateY(-2px);
            box-shadow: var(--shadow);
        }

        .preset-item.active {
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.2);
        }

        .preset-item img {
            width: 100%;
            height: 60px;
            object-fit: cover;
            border-radius: var(--radius-sm);
            margin-bottom: var(--spacing-2);
        }

        .preset-item span {
            font-size: 0.875rem;
            color: var(--text-secondary);
            display: block;
        }

        .custom-upload {
            margin-bottom: var(--spacing-4);
            padding-top: var(--spacing-4);
            border-top: 1px solid var(--border);
        }

        .background-preview {
            margin-top: var(--spacing-4);
            display: none;
        }

        .background-preview img {
            max-width: 200px;
            max-height: 150px;
            border-radius: var(--radius);
            border: 2px solid var(--accent-blue);
        }

        #hiddenVideo {
            display: none;
        }

        @media (max-width: 768px) {
            .container {
                padding: var(--spacing-2);
            }

            h1 {
                font-size: 2rem;
            }

            .controls {
                flex-direction: column;
                align-items: center;
            }

            .btn {
                width: 100%;
                max-width: 300px;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>üì∏ Kamera Web-App</h1>
        <p class="subtitle">Nimm Fotos direkt im Browser auf</p>
    </div>

    <div id="status" class="status hidden"></div>

    <div class="camera-section">
        <div class="video-container">
            <video id="hiddenVideo" autoplay muted playsinline style="display: none;"></video>
            <video id="video" autoplay muted playsinline></video>
            <canvas id="canvas" class="hidden"></canvas>
        </div>

        <div class="controls">
            <button id="startBtn" class="btn btn-primary">üé• Kamera starten</button>
            <button id="photoBtn" class="btn btn-secondary hidden" disabled>üì∑ Foto aufnehmen
            </button>
            <button id="stopBtn" class="btn btn-danger hidden">‚èπÔ∏è Kamera stoppen</button>
        </div>
    </div>

    <div class="filter-section hidden" id="filterSection">
        <h3 style="margin-bottom: 1rem; color: var(--accent-blue);">üé® Filter & Effekte</h3>
        
        <div class="filter-presets">
            <div class="filter-preset active" data-preset="normal">Normal</div>
            <div class="filter-preset" data-preset="vintage">Vintage</div>
            <div class="filter-preset" data-preset="blackwhite">S/W</div>
            <div class="filter-preset" data-preset="warm">Warm</div>
            <div class="filter-preset" data-preset="cold">Kalt</div>
            <div class="filter-preset" data-preset="dramatic">Dramatisch</div>
            <div class="filter-preset" data-preset="blur">Blur</div>
            <div class="filter-preset" data-preset="bokeh">Bokeh</div>
        </div>

        <div class="filter-controls">
            <div class="filter-control">
                <label>Unsch√§rfe <span class="filter-value" id="blurValue">0</span></label>
                <input type="range" class="filter-slider" id="blurSlider" min="0" max="20" value="0" step="0.5">
            </div>
            <div class="filter-control">
                <label>Helligkeit <span class="filter-value" id="brightnessValue">100%</span></label>
                <input type="range" class="filter-slider" id="brightnessSlider" min="0" max="200" value="100">
            </div>
            <div class="filter-control">
                <label>Kontrast <span class="filter-value" id="contrastValue">100%</span></label>
                <input type="range" class="filter-slider" id="contrastSlider" min="0" max="200" value="100">
            </div>
            <div class="filter-control">
                <label>S√§ttigung <span class="filter-value" id="saturateValue">100%</span></label>
                <input type="range" class="filter-slider" id="saturateSlider" min="0" max="200" value="100">
            </div>
            <div class="filter-control">
                <label>Graustufen <span class="filter-value" id="grayscaleValue">0%</span></label>
                <input type="range" class="filter-slider" id="grayscaleSlider" min="0" max="100" value="0">
            </div>
            <div class="filter-control">
                <label>Sepia <span class="filter-value" id="sepiaValue">0%</span></label>
                <input type="range" class="filter-slider" id="sepiaSlider" min="0" max="100" value="0">
            </div>
        </div>

        <div style="margin-top: 1rem;">
            <button class="btn btn-secondary" id="resetFiltersBtn">üîÑ Filter zur√ºcksetzen</button>
        </div>
    </div>

    <div class="background-section hidden" id="backgroundSection">
        <h3 style="margin-bottom: 1rem; color: var(--accent-blue);">üñºÔ∏è Hintergrund</h3>
        
        <div class="background-options">
            <div class="background-option active" data-background="none">
                <div class="background-option-icon">üé•</div>
                <div>Original</div>
            </div>
            <div class="background-option" data-background="blur">
                <div class="background-option-icon">üå´Ô∏è</div>
                <div>Unsch√§rfe</div>
            </div>
            <div class="background-option" data-background="custom">
                <div class="background-option-icon">üñºÔ∏è</div>
                <div>Eigenes Bild</div>
            </div>
        </div>

        <div class="upload-section hidden" id="uploadSection">
            <h4 style="margin-bottom: 1rem; color: var(--accent-blue);">üñºÔ∏è Hintergrund ausw√§hlen</h4>
            
            <!-- Vordefinierte Hintergr√ºnde -->
            <div class="background-presets">
                <h5 style="margin-bottom: 0.5rem; color: var(--text-secondary);">Vorlagen:</h5>
                <div class="preset-gallery" id="presetGallery">
                    <div class="preset-item" data-preset="code">
                        <img src="backgrounds/code.png" alt="Code Hintergrund">
                        <span>Code</span>
                    </div>
                </div>
            </div>
            
            <!-- Eigenes Bild hochladen -->
            <div class="custom-upload">
                <h5 style="margin-bottom: 0.5rem; color: var(--text-secondary);">Eigenes Bild:</h5>
                <input type="file" id="backgroundUpload" accept="image/*">
                <label for="backgroundUpload" class="upload-btn">
                    üì§ Bild hochladen
                </label>
            </div>
            
            <div class="background-preview" id="backgroundPreview">
                <p style="margin-bottom: 0.5rem; color: var(--text-secondary);">Aktueller Hintergrund:</p>
                <img id="previewImage" src="" alt="Hintergrund Vorschau">
            </div>
        </div>
    </div>

    <div id="photosSection" class="hidden">
        <h3 style="margin-bottom: 1rem; color: var(--accent-blue);">Aufgenommene Fotos</h3>
        <div id="photosGrid" class="photos-grid"></div>
    </div>
</div>

<script>
    let stream = null;
    let photos = [];

    const video = document.getElementById('video');
    const hiddenVideo = document.getElementById('hiddenVideo');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const photoBtn = document.getElementById('photoBtn');
    const stopBtn = document.getElementById('stopBtn');
    const status = document.getElementById('status');
    const photosSection = document.getElementById('photosSection');
    const photosGrid = document.getElementById('photosGrid');
    const filterSection = document.getElementById('filterSection');
    const resetFiltersBtn = document.getElementById('resetFiltersBtn');
    const backgroundSection = document.getElementById('backgroundSection');
    const uploadSection = document.getElementById('uploadSection');
    const backgroundUpload = document.getElementById('backgroundUpload');
    const backgroundPreview = document.getElementById('backgroundPreview');
    const previewImage = document.getElementById('previewImage');

    // Filter state
    let currentFilters = {
        blur: 0,
        brightness: 100,
        contrast: 100,
        saturate: 100,
        grayscale: 0,
        sepia: 0
    };

    // Filter presets
    const filterPresets = {
        normal: { blur: 0, brightness: 100, contrast: 100, saturate: 100, grayscale: 0, sepia: 0 },
        vintage: { blur: 0, brightness: 110, contrast: 90, saturate: 70, grayscale: 0, sepia: 40 },
        blackwhite: { blur: 0, brightness: 100, contrast: 120, saturate: 0, grayscale: 100, sepia: 0 },
        warm: { blur: 0, brightness: 110, contrast: 100, saturate: 130, grayscale: 0, sepia: 20 },
        cold: { blur: 0, brightness: 100, contrast: 110, saturate: 80, grayscale: 10, sepia: 0 },
        dramatic: { blur: 0, brightness: 90, contrast: 140, saturate: 110, grayscale: 0, sepia: 0 },
        blur: { blur: 8, brightness: 100, contrast: 100, saturate: 100, grayscale: 0, sepia: 0 },
        bokeh: { blur: 0, brightness: 105, contrast: 95, saturate: 110, grayscale: 0, sepia: 0 }
    };

    // Get all filter elements
    const filterSliders = {
        blur: document.getElementById('blurSlider'),
        brightness: document.getElementById('brightnessSlider'),
        contrast: document.getElementById('contrastSlider'),
        saturate: document.getElementById('saturateSlider'),
        grayscale: document.getElementById('grayscaleSlider'),
        sepia: document.getElementById('sepiaSlider')
    };

    const filterValues = {
        blur: document.getElementById('blurValue'),
        brightness: document.getElementById('brightnessValue'),
        contrast: document.getElementById('contrastValue'),
        saturate: document.getElementById('saturateValue'),
        grayscale: document.getElementById('grayscaleValue'),
        sepia: document.getElementById('sepiaValue')
    };

    // Background state
    let backgroundMode = 'none'; // none, blur, custom
    let customBackgroundImage = null;
    let segmentationActive = false;
    let selfieSegmentation = null;
    let segmentationResults = null;
    
    // Background presets
    const backgroundPresets = {
        code: 'backgrounds/code.png'
    };

    // Initialize MediaPipe SelfieSegmentation
    async function initializeMediaPipe() {
        try {
            console.log('Initializing MediaPipe SelfieSegmentation...');
            
            selfieSegmentation = new SelfieSegmentation({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation@0.1.1632777926/${file}`;
                }
            });

            selfieSegmentation.setOptions({
                modelSelection: 0,
                selfieMode: false,
                effectSelection: 1
            });

            selfieSegmentation.onResults(onSegmentationResults);
            
            console.log('‚úÖ MediaPipe SelfieSegmentation initialized');
            return true;
            
        } catch (error) {
            console.error('‚ùå MediaPipe initialization failed:', error);
            return false;
        }
    }

    // Handle segmentation results from MediaPipe
    function onSegmentationResults(results) {
        if (!segmentationActive) return;
        
        try {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (backgroundMode === 'blur') {
                // Create temp canvas for blurred background
                const blurCanvas = document.createElement('canvas');
                blurCanvas.width = canvas.width;
                blurCanvas.height = canvas.height;
                const blurCtx = blurCanvas.getContext('2d');
                
                // Draw blurred background
                blurCtx.filter = 'blur(20px)';
                blurCtx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
                ctx.drawImage(blurCanvas, 0, 0);
                
            } else if (backgroundMode === 'custom' && customBackgroundImage) {
                // Draw custom background with proper aspect ratio
                const imgAspect = customBackgroundImage.width / customBackgroundImage.height;
                const canvasAspect = canvas.width / canvas.height;
                
                let drawWidth, drawHeight, offsetX = 0, offsetY = 0;
                
                if (imgAspect > canvasAspect) {
                    drawHeight = canvas.height;
                    drawWidth = drawHeight * imgAspect;
                    offsetX = (canvas.width - drawWidth) / 2;
                } else {
                    drawWidth = canvas.width;
                    drawHeight = drawWidth / imgAspect;
                    offsetY = (canvas.height - drawHeight) / 2;
                }
                
                // Draw the custom background
                ctx.drawImage(customBackgroundImage, offsetX, offsetY, drawWidth, drawHeight);
                
            } else {
                // No background effect, just draw the original video
                ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
                return; // No need for person mask overlay
            }
            
            // Create mask canvas for person overlay
            const maskCanvas = document.createElement('canvas');
            maskCanvas.width = canvas.width;
            maskCanvas.height = canvas.height;
            const maskCtx = maskCanvas.getContext('2d');
            
            // Draw original image
            maskCtx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            
            // Apply segmentation mask
            maskCtx.globalCompositeOperation = 'destination-in';
            maskCtx.drawImage(results.segmentationMask, 0, 0, canvas.width, canvas.height);
            
            // Draw person on top of background
            ctx.drawImage(maskCanvas, 0, 0);
            
        } catch (error) {
            console.error('Segmentation error:', error);
            // Fallback: just draw the video
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        }
    }

    // Draw the segmented image with background effects
    function drawSegmentedImage() {
        if (!segmentationResults || !segmentationResults.segmentationMask) {
            console.log('No segmentation results or mask available');
            return;
        }

        try {
            console.log('Drawing segmented image, canvas size:', canvas.width, 'x', canvas.height);
            console.log('segmentationResults.image:', segmentationResults.image);
            console.log('segmentationResults.segmentationMask:', segmentationResults.segmentationMask);
            
            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (backgroundMode === 'blur') {
                console.log('Testing MediaPipe ImageBitmap drawing...');
                
                try {
                    // TEST: Debug hiddenVideo state before drawing
                    console.log('Testing direct hiddenVideo draw...');
                    console.log('hiddenVideo.videoWidth:', hiddenVideo.videoWidth);
                    console.log('hiddenVideo.videoHeight:', hiddenVideo.videoHeight);  
                    console.log('hiddenVideo.readyState:', hiddenVideo.readyState);
                    console.log('hiddenVideo.srcObject:', hiddenVideo.srcObject);
                    
                    // Draw the video frame
                    if (hiddenVideo.videoWidth > 0 && hiddenVideo.videoHeight > 0) {
                        ctx.drawImage(hiddenVideo, 0, 0, canvas.width, canvas.height);
                        console.log('‚úÖ Video frame drawn successfully');
                        
                        // Apply background blur if MediaPipe segmentation is available
                        if (segmentationResults && segmentationResults.segmentationMask) {
                            applyBackgroundBlurWithSegmentation();
                        } else {
                            // Apply simple blur effect to entire frame
                            applySimpleBackgroundBlur();
                        }
                    } else {
                        console.log('‚ùå hiddenVideo not ready - using main video instead');
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        applySimpleBackgroundBlur();
                    }
                } catch (error) {
                    console.error('‚ùå Error drawing hiddenVideo:', error);
                    
                    // Try MediaPipe image with different approach
                    try {
                        console.log('Trying MediaPipe image with createImageBitmap...');
                        
                        // Draw MediaPipe image directly
                        ctx.drawImage(segmentationResults.image, 0, 0, canvas.width, canvas.height);
                        console.log('‚úÖ MediaPipe image drawn with fallback!');
                        
                    } catch (error2) {
                        console.error('‚ùå MediaPipe drawing failed completely:', error2);
                        // Draw test pattern to show failure
                        ctx.fillStyle = 'red';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        console.log('Drew red error background');
                    }
                }
                
            } else if (backgroundMode === 'custom' && customBackgroundImage) {
                console.log('Applying custom background with person segmentation...');
                
                // Step 1: Draw custom background with proper aspect ratio
                const imgAspect = customBackgroundImage.width / customBackgroundImage.height;
                const canvasAspect = canvas.width / canvas.height;
                
                let drawWidth, drawHeight, offsetX = 0, offsetY = 0;
                
                if (imgAspect > canvasAspect) {
                    drawHeight = canvas.height;
                    drawWidth = drawHeight * imgAspect;
                    offsetX = (canvas.width - drawWidth) / 2;
                } else {
                    drawWidth = canvas.width;
                    drawHeight = drawWidth / imgAspect;
                    offsetY = (canvas.height - drawHeight) / 2;
                }
                
                // Draw the custom background
                ctx.drawImage(customBackgroundImage, offsetX, offsetY, drawWidth, drawHeight);
                
                // Step 2: Create person-only layer using segmentation
                const personCanvas = document.createElement('canvas');
                personCanvas.width = canvas.width;
                personCanvas.height = canvas.height;
                const personCtx = personCanvas.getContext('2d');
                
                // Draw the original sharp image
                personCtx.drawImage(segmentationResults.image, 0, 0, canvas.width, canvas.height);
                
                // Apply segmentation mask to keep only the person
                personCtx.globalCompositeOperation = 'destination-in';
                personCtx.drawImage(segmentationResults.segmentationMask, 0, 0, canvas.width, canvas.height);
                
                // Step 3: Overlay person on custom background
                ctx.drawImage(personCanvas, 0, 0);
                
                console.log('Custom background with person segmentation applied successfully');
            }

            // Reset composite operation
            ctx.globalCompositeOperation = 'source-over';

            // Apply additional filters if any
            if (video.style.filter && video.style.filter !== 'none') {
                const filterCanvas = document.createElement('canvas');
                filterCanvas.width = canvas.width;
                filterCanvas.height = canvas.height;
                const filterCtx = filterCanvas.getContext('2d');
                
                filterCtx.filter = video.style.filter;
                filterCtx.drawImage(canvas, 0, 0);
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(filterCanvas, 0, 0);
            }

            ctx.restore();
        } catch (error) {
            console.error('Segmentation drawing error:', error);
            fallbackToSimpleBlur();
        }
    }

    // Apply background blur with person segmentation
    function applyBackgroundBlurWithSegmentation() {
        try {
            console.log('Applying background blur with person segmentation...');
            
            // Get current frame data
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Create blurred version of the frame
            const blurredCanvas = document.createElement('canvas');
            blurredCanvas.width = canvas.width;
            blurredCanvas.height = canvas.height;
            const blurredCtx = blurredCanvas.getContext('2d');
            
            // Draw video to blur canvas
            blurredCtx.drawImage(hiddenVideo, 0, 0, canvas.width, canvas.height);
            blurredCtx.filter = 'blur(15px)';
            blurredCtx.drawImage(blurredCanvas, 0, 0);
            
            // Apply segmentation mask to composite person over blurred background
            ctx.save();
            ctx.globalCompositeOperation = 'source-over';
            
            // Draw blurred background
            ctx.drawImage(blurredCanvas, 0, 0);
            
            // Draw person using segmentation mask
            // This is a simplified approach - would need proper mask processing for perfect results
            ctx.globalCompositeOperation = 'source-atop';
            if (segmentationResults && segmentationResults.image) {
                ctx.drawImage(segmentationResults.image, 0, 0, canvas.width, canvas.height);
            }
            
            ctx.restore();
            console.log('‚úÖ Background blur with segmentation applied');
            
        } catch (error) {
            console.error('‚ùå Segmentation blur failed:', error);
            applySimpleBackgroundBlur();
        }
    }

    // Apply simple background blur (fallback)
    function applySimpleBackgroundBlur() {
        try {
            console.log('Applying simple background blur...');
            
            // Apply CSS filter blur effect
            ctx.save();
            ctx.filter = 'blur(8px)';
            ctx.drawImage(hiddenVideo, 0, 0, canvas.width, canvas.height);
            ctx.restore();
            
            console.log('‚úÖ Simple background blur applied');
            
        } catch (error) {
            console.error('‚ùå Simple blur failed:', error);
        }
    }

    function showStatus(message, type = 'success') {
        status.textContent = message;
        status.className = `status ${type}`;
        status.classList.remove('hidden');

        setTimeout(() => {
            status.classList.add('hidden');
        }, 3000);
    }

    async function startCamera() {
        try {
            stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    width: {ideal: 1280},
                    height: {ideal: 720}
                },
                audio: false
            });

            video.srcObject = stream;

            // UI aktualisieren
            startBtn.classList.add('hidden');
            photoBtn.classList.remove('hidden');
            stopBtn.classList.remove('hidden');
            photoBtn.disabled = false;
            filterSection.classList.remove('hidden');
            backgroundSection.classList.remove('hidden');

            // Always initialize MediaPipe fresh for each camera start
            console.log('Initializing MediaPipe for new camera session...');
            await initializeMediaPipe();

            // Set up video for MediaPipe
            hiddenVideo.srcObject = stream;
            console.log('Stream assigned to hiddenVideo:', stream);
            console.log('HiddenVideo dimensions:', hiddenVideo.videoWidth, 'x', hiddenVideo.videoHeight);

            // Canvas and MediaPipe setup complete

            showStatus('Kamera erfolgreich gestartet!');

        } catch (error) {
            console.error('Fehler beim Zugriff auf Kamera:', error);
            showStatus('Fehler beim Zugriff auf die Kamera. Berechtigung erteilt?', 'error');
        }
    }

    function stopCamera() {
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null;
            video.srcObject = null;
            hiddenVideo.srcObject = null;
        }

        // UI zur√ºcksetzen
        startBtn.classList.remove('hidden');
        photoBtn.classList.add('hidden');
        stopBtn.classList.add('hidden');
        photoBtn.disabled = true;

        showStatus('Kamera gestoppt');
        filterSection.classList.add('hidden');
        backgroundSection.classList.add('hidden');
        
        // Reset all background states
        segmentationActive = false;
        backgroundMode = 'none';
        
        // Reset canvas and video visibility
        canvas.classList.add('hidden');
        video.classList.remove('hidden');
        canvas.style.display = '';
        video.style.display = '';
        
        // Clear canvas
        if (ctx) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        // Reset MediaPipe
        selfieSegmentation = null;
        segmentationResults = null;
        
        // Reset UI states
        document.querySelectorAll('.background-option').forEach(option => {
            option.classList.remove('active');
        });
        document.querySelector('[data-background="none"]').classList.add('active');
        uploadSection.classList.add('hidden');
    }

    // Background functions
    async function startBackgroundProcessing() {
        console.log('Starting MediaPipe background processing...');
        console.log('Stream available:', !!stream);
        
        if (!stream || !selfieSegmentation) {
            console.error('Missing stream or MediaPipe not initialized');
            showStatus('Hintergrund-Verarbeitung nicht verf√ºgbar', 'error');
            return;
        }

        segmentationActive = true;
        
        // Wait for video to be ready
        const waitForVideo = () => {
            console.log('Waiting for video... Current dimensions:', hiddenVideo.videoWidth, 'x', hiddenVideo.videoHeight);
            
            if (hiddenVideo.videoWidth > 0 && hiddenVideo.videoHeight > 0) {
                console.log('Video ready, setting canvas dimensions:', hiddenVideo.videoWidth, 'x', hiddenVideo.videoHeight);
                
                // Set canvas dimensions to match video
                canvas.width = hiddenVideo.videoWidth;
                canvas.height = hiddenVideo.videoHeight;
                
                // Calculate display size to maintain aspect ratio
                const aspectRatio = hiddenVideo.videoWidth / hiddenVideo.videoHeight;
                const maxWidth = 640;
                let displayWidth = hiddenVideo.videoWidth;
                let displayHeight = hiddenVideo.videoHeight;
                
                if (displayWidth > maxWidth) {
                    displayWidth = maxWidth;
                    displayHeight = maxWidth / aspectRatio;
                }
                
                // Set CSS display dimensions to match video element
                canvas.style.width = '100%';
                canvas.style.height = 'auto';
                canvas.style.aspectRatio = aspectRatio;
                
                // Show canvas and hide video using CSS classes
                canvas.classList.remove('hidden');
                video.classList.add('hidden');
                
                console.log('Canvas configured - Display size:', displayWidth + 'x' + displayHeight, 'Internal size:', canvas.width + 'x' + canvas.height);
                console.log('Canvas visibility:', !canvas.classList.contains('hidden'), 'Video visibility:', !video.classList.contains('hidden'));
                
                showStatus('MediaPipe Hintergrund-Effekt aktiv', 'success');
                
                // Process frames using MediaPipe
                // Create MediaPipe Camera for continuous processing
                const camera = new Camera(hiddenVideo, {
                    onFrame: async () => {
                        if (segmentationActive && selfieSegmentation) {
                            await selfieSegmentation.send({image: hiddenVideo});
                        }
                    },
                    width: 1280,
                    height: 720
                });
                
                camera.start().catch(error => {
                    console.error('Camera start error:', error);
                    fallbackToSimpleBlur();
                });
            } else {
                setTimeout(waitForVideo, 100);
            }
        };
        
        waitForVideo();
    }

    function stopBackgroundProcessing() {
        console.log('Stopping background processing and resetting states...');
        
        segmentationActive = false;
        
        // Reset canvas and video visibility
        canvas.classList.add('hidden');
        video.classList.remove('hidden');
        video.style.filter = 'none';
        
        // Clear canvas completely
        if (ctx) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        // Reset canvas display style
        canvas.style.display = '';
        video.style.display = '';
        
        console.log('‚úÖ Background processing stopped and states reset');
    }

    // Fallback function for simple blur without segmentation
    function fallbackToSimpleBlur() {
        console.log('Starting continuous background blur rendering...');
        
        if (backgroundMode === 'blur') {
            showStatus('Hintergrund-Blur aktiv (Live-Video)', 'success');
            
            // Ensure we have a fresh animation loop
            let animationId = null;
            
            const renderLiveBlurFrame = () => {
                if (segmentationActive && backgroundMode === 'blur') {
                    // Clear entire canvas first
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Step 1: Draw full blurred background
                    ctx.save();
                    ctx.filter = 'blur(15px)';
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    ctx.restore();
                    
                    // Step 2: Draw sharp person area on top
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2 - canvas.height * 0.05; // Slightly up for head
                    const personWidth = canvas.width * 0.4;
                    const personHeight = canvas.height * 0.8;
                    
                    // Create smooth mask for person area
                    ctx.save();
                    ctx.globalCompositeOperation = 'source-over';
                    
                    // Create elliptical clipping path for person
                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY, personWidth/2, personHeight/2, 0, 0, 2 * Math.PI);
                    ctx.clip();
                    
                    // Draw sharp person
                    ctx.filter = 'none';
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    ctx.restore();
                    
                    // Continue animation
                    animationId = requestAnimationFrame(renderLiveBlurFrame);
                }
            };
            
            // Cancel any existing animation
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            console.log('‚úÖ Starting live blur rendering...');
            renderLiveBlurFrame();
            
        } else {
            // Not blur mode, hide canvas and show video
            segmentationActive = false;
            canvas.classList.add('hidden');
            video.classList.remove('hidden');
        }
    }

    function setBackgroundMode(mode) {
        console.log('Setting background mode to:', mode);
        backgroundMode = mode;

        // Update UI
        document.querySelectorAll('.background-option').forEach(option => {
            option.classList.remove('active');
        });
        document.querySelector(`[data-background="${mode}"]`).classList.add('active');

        if (mode === 'none') {
            stopBackgroundProcessing();
            uploadSection.classList.add('hidden');
        } else {
            // Always check if camera is running first
            if (!stream) {
                showStatus('Kamera muss zuerst gestartet werden', 'error');
                return;
            }
            
            // Initialize MediaPipe if needed before starting
            if (!selfieSegmentation) {
                console.log('MediaPipe not initialized, initializing now...');
                initializeMediaPipe().then(() => {
                    setTimeout(() => {
                        startBackgroundProcessing();
                    }, 500);
                });
            } else {
                console.log('MediaPipe already initialized, starting processing...');
                startBackgroundProcessing();
            }
            
            // Add timeout fallback in case processing fails
            setTimeout(() => {
                if ((backgroundMode === 'blur' || backgroundMode === 'custom') && canvas.style.display === 'none') {
                    console.log('MediaPipe processing timeout, using fallback');
                    fallbackToSimpleBlur();
                }
            }, 3000);
            
            if (mode === 'custom') {
                uploadSection.classList.remove('hidden');
            } else {
                uploadSection.classList.add('hidden');
            }
        }

        showStatus(`Hintergrund: ${mode === 'none' ? 'Original' : mode === 'blur' ? 'Unsch√§rfe mit MediaPipe' : 'Eigenes Bild'}`);
    }

    function handleBackgroundUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        // Remove active state from presets when uploading custom image
        document.querySelectorAll('.preset-item').forEach(item => {
            item.classList.remove('active');
        });

        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                customBackgroundImage = img;
                showBackgroundPreview(img.src);
                showStatus('Eigenes Hintergrundbild geladen');
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    // Filter functions
    function updateFilterValues() {
        filterValues.blur.textContent = currentFilters.blur + 'px';
        filterValues.brightness.textContent = currentFilters.brightness + '%';
        filterValues.contrast.textContent = currentFilters.contrast + '%';
        filterValues.saturate.textContent = currentFilters.saturate + '%';
        filterValues.grayscale.textContent = currentFilters.grayscale + '%';
        filterValues.sepia.textContent = currentFilters.sepia + '%';
    }

    function applyFiltersToVideo() {
        const filterString = `
            blur(${currentFilters.blur}px)
            brightness(${currentFilters.brightness}%)
            contrast(${currentFilters.contrast}%)
            saturate(${currentFilters.saturate}%)
            grayscale(${currentFilters.grayscale}%)
            sepia(${currentFilters.sepia}%)
        `;
        video.style.filter = filterString;
    }

    function applyFiltersToCanvas(imageData) {
        // Apply filters to canvas for photo capture
        ctx.filter = `
            blur(${currentFilters.blur}px)
            brightness(${currentFilters.brightness}%)
            contrast(${currentFilters.contrast}%)
            saturate(${currentFilters.saturate}%)
            grayscale(${currentFilters.grayscale}%)
            sepia(${currentFilters.sepia}%)
        `;
    }

    function applyPreset(presetName) {
        const preset = filterPresets[presetName];
        if (!preset) return;

        currentFilters = { ...preset };
        
        // Update sliders
        Object.keys(filterSliders).forEach(key => {
            filterSliders[key].value = currentFilters[key];
        });

        updateFilterValues();
        applyFiltersToVideo();

        // Update active preset button
        document.querySelectorAll('.filter-preset').forEach(btn => {
            btn.classList.remove('active');
        });
        document.querySelector(`[data-preset="${presetName}"]`).classList.add('active');
    }

    function resetFilters() {
        applyPreset('normal');
        showStatus('Filter zur√ºckgesetzt');
    }

    // Special bokeh effect implementation
    function applyBokehEffect(ctx, canvas) {
        // Create a radial gradient for depth simulation
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = Math.min(canvas.width, canvas.height) * 0.4;
        
        // Save current state
        ctx.save();
        
        // Create temporary canvas for the blurred background
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        const tempCtx = tempCanvas.getContext('2d');
        
        // Draw blurred version
        tempCtx.filter = 'blur(15px)';
        tempCtx.drawImage(canvas, 0, 0);
        
        // Clear original canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw blurred background
        ctx.drawImage(tempCanvas, 0, 0);
        
        // Create radial gradient mask
        ctx.globalCompositeOperation = 'destination-out';
        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
        gradient.addColorStop(0, 'rgba(0,0,0,1)');
        gradient.addColorStop(0.5, 'rgba(0,0,0,0.8)');
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw sharp center
        ctx.globalCompositeOperation = 'destination-over';
        ctx.filter = 'none';
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        // Restore state
        ctx.restore();
    }

    function takePhoto() {
        if (!stream) return;

        // Create temporary canvas for photo
        const photoCanvas = document.createElement('canvas');
        photoCanvas.width = video.videoWidth;
        photoCanvas.height = video.videoHeight;
        const photoCtx = photoCanvas.getContext('2d');

        // If background processing is active, copy from main canvas
        if (segmentationActive && backgroundMode !== 'none' && canvas.style.display !== 'none') {
            photoCtx.drawImage(canvas, 0, 0);
        } else {
            // Check if bokeh effect is active
            const isBokeh = document.querySelector('[data-preset="bokeh"]').classList.contains('active');
            
            if (isBokeh) {
                // First draw the video without filters
                photoCtx.filter = 'none';
                photoCtx.drawImage(video, 0, 0);
                // Then apply bokeh effect
                applyBokehEffect(photoCtx, photoCanvas);
            } else {
                // Apply regular filters
                photoCtx.filter = `
                    blur(${currentFilters.blur}px)
                    brightness(${currentFilters.brightness}%)
                    contrast(${currentFilters.contrast}%)
                    saturate(${currentFilters.saturate}%)
                    grayscale(${currentFilters.grayscale}%)
                    sepia(${currentFilters.sepia}%)
                `;
                // Video-Frame auf Canvas zeichnen
                photoCtx.drawImage(video, 0, 0);
            }
        }

        // Foto als Data URL erstellen
        const photoDataUrl = photoCanvas.toDataURL('image/jpeg', 0.9);

        // Foto zur Liste hinzuf√ºgen
        const timestamp = new Date().toLocaleString('de-DE');
        const photo = {
            id: Date.now(),
            dataUrl: photoDataUrl,
            timestamp: timestamp
        };

        photos.unshift(photo); // Am Anfang hinzuf√ºgen
        updatePhotosGrid();

        showStatus(`Foto aufgenommen! (${photos.length} Fotos gespeichert)`);
    }

    function updatePhotosGrid() {
        if (photos.length === 0) {
            photosSection.classList.add('hidden');
            return;
        }

        photosSection.classList.remove('hidden');
        photosGrid.innerHTML = '';

        photos.forEach(photo => {
            const photoItem = document.createElement('div');
            photoItem.className = 'photo-item';
            photoItem.innerHTML = `
                    <img src="${photo.dataUrl}" alt="Foto vom ${photo.timestamp}">
                    <div class="timestamp">${photo.timestamp}</div>
                    <button class="btn btn-primary" onclick="downloadPhoto('${photo.dataUrl}', '${photo.timestamp}')">
                        üíæ Herunterladen
                    </button>
                `;
            photosGrid.appendChild(photoItem);
        });
    }

    function downloadPhoto(dataUrl, timestamp) {
        const link = document.createElement('a');
        link.download = `foto_${timestamp.replace(/[\/\s:]/g, '_')}.jpg`;
        link.href = dataUrl;
        link.click();
    }

    // Event Listeners
    startBtn.addEventListener('click', startCamera);
    stopBtn.addEventListener('click', stopCamera);
    photoBtn.addEventListener('click', takePhoto);
    resetFiltersBtn.addEventListener('click', resetFilters);
    backgroundUpload.addEventListener('change', handleBackgroundUpload);

    // Filter preset listeners
    document.querySelectorAll('.filter-preset').forEach(preset => {
        preset.addEventListener('click', (e) => {
            const presetName = e.target.dataset.preset;
            applyPreset(presetName);
        });
    });

    // Filter slider listeners
    Object.keys(filterSliders).forEach(key => {
        filterSliders[key].addEventListener('input', (e) => {
            currentFilters[key] = parseFloat(e.target.value);
            updateFilterValues();
            applyFiltersToVideo();
            
            // Remove active state from presets when manually adjusting
            document.querySelectorAll('.filter-preset').forEach(btn => {
                btn.classList.remove('active');
            });
        });
    });

    // Background option listeners
    document.querySelectorAll('.background-option').forEach(option => {
        option.addEventListener('click', (e) => {
            const mode = e.currentTarget.dataset.background;
            setBackgroundMode(mode);
        });
    });

    // Background preset gallery listeners
    document.querySelectorAll('.preset-item').forEach(preset => {
        preset.addEventListener('click', (e) => {
            const presetName = e.currentTarget.dataset.preset;
            selectBackgroundPreset(presetName);
        });
    });

    // Function to select a background preset
    function selectBackgroundPreset(presetName) {
        console.log(`Selecting background preset: ${presetName}`);
        
        // Remove active class from all presets
        document.querySelectorAll('.preset-item').forEach(item => {
            item.classList.remove('active');
        });
        
        // Add active class to selected preset
        document.querySelector(`[data-preset="${presetName}"]`).classList.add('active');
        
        // Load the preset image
        const presetPath = backgroundPresets[presetName];
        if (presetPath) {
            const img = new Image();
            img.onload = () => {
                customBackgroundImage = img;
                showBackgroundPreview(img.src);
                console.log(`‚úÖ Background preset "${presetName}" loaded successfully`);
                
                // If custom background mode is already active, apply immediately
                if (backgroundMode === 'custom') {
                    // Refresh the background processing
                    if (segmentationActive) {
                        console.log('Refreshing background with new preset...');
                    }
                }
            };
            img.onerror = () => {
                console.error(`‚ùå Failed to load background preset: ${presetPath}`);
                showStatus('Fehler beim Laden des Hintergrunds', 'error');
            };
            img.src = presetPath;
        }
    }

    // Function to show background preview
    function showBackgroundPreview(imageSrc) {
        const previewImage = document.getElementById('previewImage');
        const backgroundPreview = document.getElementById('backgroundPreview');
        
        previewImage.src = imageSrc;
        backgroundPreview.style.display = 'block';
    }

    // Keyboard Shortcuts
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && !photoBtn.classList.contains('hidden') && !photoBtn.disabled) {
            e.preventDefault();
            takePhoto();
        }
    });
</script>
</body>
</html>