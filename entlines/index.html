<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Entlines - Flappy Duck Adventure | Fliege durch die RÃ¶hren!</title>
    <meta name="description"
          content="Entlines ist ein sÃ¼chtig machendes Flappy Bird Spiel mit einer charmanten Ente! Fliege durch endlose RÃ¶hren, sammle Punkte und genieÃŸe die Learning to Fly Melodie. Kostenlos spielen im Browser!">
    <meta name="keywords"
          content="Entlines, Flappy Bird, Ente, Spiel, Browser Game, Arcade, Fliegen, Learning to Fly">
    <meta name="author" content="Entlines Game">
    
    <!-- PWA Meta Tags -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#87CEEB">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Entlines">
    <link rel="apple-touch-icon" href="apple-touch-icon.png">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="game">
    <meta property="og:title" content="Entlines - Flappy Duck Adventure">
    <meta property="og:description"
          content="Fliege mit einer charmanten Ente durch endlose RÃ¶hren! SÃ¼chtig machendes Flappy Bird Spiel mit Learning to Fly Melodie.">
    <meta property="og:image" content="entlines.jpg">
    <meta property="og:url" content="">
    <meta property="og:site_name" content="Entlines">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Entlines - Flappy Duck Adventure">
    <meta name="twitter:description"
          content="Fliege mit einer charmanten Ente durch endlose RÃ¶hren! SÃ¼chtig machendes Browser-Spiel mit toller Musik.">
    <meta name="twitter:image" content="entlines.jpg">

    <!-- Mobile -->
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Entlines">
    <meta name="apple-touch-icon" content="entlines.jpg">

    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1b2e 0%, #16213e 50%, #0f3460 100%);
            background-attachment: fixed;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 20% 80%, rgba(255, 193, 7, 0.1) 0%, transparent 50%),
            radial-gradient(circle at 80% 20%, rgba(255, 183, 0, 0.15) 0%, transparent 50%),
            radial-gradient(circle at 40% 40%, rgba(26, 27, 46, 0.3) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }

        #gameContainer {
            position: relative;
            background: linear-gradient(to bottom, #87CEEB, #98FB98);
            border: 4px solid rgba(255, 255, 255, 0.8);
            border-radius: 25px;
            overflow: hidden;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.4),
            0 0 30px rgba(255, 255, 255, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            transform: translateZ(0);
            max-width: 95vw;
            max-height: 95vh;
        }

        canvas {
            display: block;
            background: radial-gradient(ellipse at center top,
            #FFB6C1 0%,
            #87CEEB 20%,
            #98CED6 35%,
            #87CEEB 50%,
            #B4E7CE 70%,
            #F0E68C 85%,
            #DDA0DD 100%);
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
        }

        .footer {
            position: fixed;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            font-weight: 300;
            letter-spacing: 0.5px;
            z-index: 1000;
            pointer-events: auto;
            cursor: default;
            user-select: none;
        }

        @media (max-width: 768px) {
            .footer {
                font-size: 10px;
                bottom: 10px;
                padding: 15px;
                border-radius: 8px;
                background: rgba(0, 0, 0, 0.1);
            }
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 32px;
            font-weight: 900;
            color: #FFFFFF;
            text-shadow: 2px 2px 0px #000000,
            -2px -2px 0px #000000,
            2px -2px 0px #000000,
            -2px 2px 0px #000000,
            0px 4px 8px rgba(0, 0, 0, 0.6);
            padding: 12px 20px;
            background: linear-gradient(135deg,
            rgba(255, 215, 0, 0.95) 0%,
            rgba(255, 165, 0, 0.95) 100%);
            border: 3px solid rgba(255, 255, 255, 0.8);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3),
            inset 0 2px 4px rgba(255, 255, 255, 0.4),
            inset 0 -2px 4px rgba(0, 0, 0, 0.2);
        }

        #musicToggle {
            position: absolute;
            top: 8px;
            right: 20px;
        }

        #musicBtn {
            background: linear-gradient(135deg,
            rgba(100, 100, 100, 0.9) 0%,
            rgba(70, 70, 70, 0.9) 100%);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.6);
            padding: 12px 16px;
            font-size: 18px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3),
            inset 0 1px 2px rgba(255, 255, 255, 0.3);
            font-weight: bold;
        }

        #musicBtn:hover {
            background: linear-gradient(135deg,
            rgba(120, 120, 120, 0.9) 0%,
            rgba(90, 90, 90, 0.9) 100%);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4),
            inset 0 1px 2px rgba(255, 255, 255, 0.4);
        }

        #musicBtn.enabled {
            background: linear-gradient(135deg,
            rgba(76, 175, 80, 0.9) 0%,
            rgba(56, 142, 60, 0.9) 100%);
        }

        #musicBtn.enabled:hover {
            background: linear-gradient(135deg,
            rgba(92, 191, 96, 0.9) 0%,
            rgba(76, 175, 80, 0.9) 100%);
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            color: #FFFFFF;
            text-shadow: 1px 1px 0px #000000,
            -1px -1px 0px #000000,
            1px -1px 0px #000000,
            -1px 1px 0px #000000,
            0px 2px 4px rgba(0, 0, 0, 0.8);
            background: rgba(0, 0, 0, 0.4);
            padding: 8px 16px;
            border-radius: 12px;
            backdrop-filter: blur(5px);
            white-space: nowrap;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 30, 0.9));
            padding: 40px;
            border-radius: 20px;
            display: none;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(15px);
        }

        button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 25px;
            cursor: pointer;
            margin-top: 15px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(238, 90, 36, 0.4);
            font-weight: bold;
        }

        button:hover {
            background: linear-gradient(45deg, #ff5252, #ff3838);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(238, 90, 36, 0.6);
        }

        /* Splash Screen Styles */
        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1b2e 0%, #16213e 50%, #0f3460 100%);
            z-index: 1000;
            display: flex;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #ffffff;
            transition: opacity 0.5s ease-out;
        }

        .splash-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .splash-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            position: relative;
            width: 100%;
        }

        .logo-container {
            position: relative;
            margin-bottom: 40px;
        }

        .circle {
            width: 200px;
            height: 200px;
            border: 4px solid #ffc107;
            border-radius: 50%;
            position: relative;
            animation: circleGlow 3s ease-in-out infinite;
        }

        .duck {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scaleX(-1) rotate(15deg);
            width: 100px;
            height: 70px;
            background: linear-gradient(135deg, #ffc107 0%, #ffb300 100%);
            border-radius: 70% 70% 50% 50%;
            animation: duckFly 2s ease-in-out infinite;
            border: 2px solid #ff8f00;
            box-shadow: inset 0 10px 20px rgba(255, 143, 0, 0.3);
        }

        .duck::before {
            content: '';
            position: absolute;
            top: -25px;
            left: 15px;
            width: 45px;
            height: 40px;
            background: linear-gradient(135deg, #ffc107 0%, #ffb300 100%);
            border-radius: 60% 60% 40% 70%;
            transform: rotate(-5deg);
            border: 2px solid #ff8f00;
            box-shadow: inset 0 5px 15px rgba(255, 143, 0, 0.2);
        }

        .duck::after {
            content: '';
            position: absolute;
            top: -6px;
            left: -2px;
            width: 12px;
            height: 6px;
            background: #ff8f00;
            border-radius: 20% 80% 50% 30%;
            transform: rotate(-5deg);
            border: 1px solid #e65100;
        }

        .duck-eye {
            position: absolute;
            top: -12px;
            left: 20px;
            width: 6px;
            height: 6px;
            background: #1a1b2e;
            border-radius: 50%;
            z-index: 10;
        }

        .duck-wing {
            position: absolute;
            top: 8px;
            right: -25px;
            width: 50px;
            height: 35px;
            background: linear-gradient(135deg, #ffb300 0%, #ff8f00 100%);
            border-radius: 60% 20% 80% 40%;
            transform-origin: left center;
            animation: wingFlapFly 0.4s ease-in-out infinite;
        }

        .wing-lines {
            position: absolute;
            top: 5px;
            right: 8px;
            width: 35px;
            height: 25px;
        }

        .wing-lines::before,
        .wing-lines::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 1.5px;
            background: #1a1b2e;
            border-radius: 1px;
        }

        .wing-lines::before {
            top: 6px;
            right: 5px;
            width: 18px;
        }

        .wing-lines::after {
            top: 12px;
            right: 8px;
            width: 15px;
        }

        .duck-tail {
            position: absolute;
            top: 25px;
            right: -15px;
            width: 25px;
            height: 20px;
            background: linear-gradient(135deg, #ffb300 0%, #ff8f00 100%);
            border-radius: 40% 80% 60% 20%;
            transform: rotate(15deg);
        }

        .underline {
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            width: 180px;
            height: 4px;
            background: #ffc107;
            border-radius: 2px;
            animation: underlineExpand 2.5s ease-out;
        }

        .title {
            font-size: 3.5rem;
            font-weight: 300;
            letter-spacing: 8px;
            color: #ffffff;
            margin-bottom: 20px;
            opacity: 0;
            animation: titleFadeIn 2s ease-out 1s forwards;
        }

        .subtitle {
            font-size: 1.2rem;
            font-weight: 300;
            letter-spacing: 2px;
            color: #ffc107;
            opacity: 0;
            animation: subtitleFadeIn 2s ease-out 1.5s forwards;
        }

        .loading-container {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            animation: loadingFadeIn 1s ease-out 2.5s forwards;
        }

        .loading-bar {
            width: 200px;
            height: 3px;
            background: rgba(255, 193, 7, 0.2);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #ffc107, #ffb300);
            width: 0%;
            border-radius: 2px;
            animation: loadingProgress 3s ease-out 2.5s forwards;
        }

        .loading-text {
            text-align: center;
            font-size: 0.9rem;
            color: #ffffff;
            opacity: 0.8;
        }

        .clouds {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .cloud {
            position: absolute;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50px;
            opacity: 0.3;
        }

        .cloud1 {
            width: 100px;
            height: 40px;
            top: 20%;
            left: 10%;
            animation: cloudFloat1 15s linear infinite;
        }

        .cloud2 {
            width: 80px;
            height: 30px;
            top: 30%;
            right: 10%;
            animation: cloudFloat2 20s linear infinite;
        }

        .cloud3 {
            width: 120px;
            height: 50px;
            top: 60%;
            left: 5%;
            animation: cloudFloat1 18s linear infinite;
        }

        @keyframes circleGlow {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 193, 7, 0.5);
            }
            50% {
                box-shadow: 0 0 40px rgba(255, 193, 7, 0.8);
            }
        }

        @keyframes duckFly {
            0%, 100% {
                transform: translate(-50%, -50%) scaleX(-1) rotate(15deg) translateY(0px) translateX(-0px);
            }
            25% {
                transform: translate(-50%, -50%) scaleX(-1) rotate(20deg) translateY(-8px) translateX(-3px);
            }
            50% {
                transform: translate(-50%, -50%) scaleX(-1) rotate(15deg) translateY(-15px) translateX(-6px);
            }
            75% {
                transform: translate(-50%, -50%) scaleX(-1) rotate(10deg) translateY(-8px) translateX(-3px);
            }
        }

        @keyframes wingFlapFly {
            0%, 100% {
                transform: rotate(-20deg) scaleY(1);
            }
            50% {
                transform: rotate(10deg) scaleY(0.8);
            }
        }

        @keyframes underlineExpand {
            0% {
                width: 0;
            }
            100% {
                width: 180px;
            }
        }

        @keyframes titleFadeIn {
            0% {
                opacity: 0;
                transform: translateY(30px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes subtitleFadeIn {
            0% {
                opacity: 0;
                transform: translateY(20px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes loadingFadeIn {
            0% {
                opacity: 0;
            }
            100% {
                opacity: 1;
            }
        }

        @keyframes loadingProgress {
            0% {
                width: 0%;
            }
            100% {
                width: 100%;
            }
        }

        @keyframes cloudFloat1 {
            0% {
                transform: translateX(-100px);
            }
            100% {
                transform: translateX(calc(100vw + 100px));
            }
        }

        @keyframes cloudFloat2 {
            0% {
                transform: translateX(calc(100vw + 100px));
            }
            100% {
                transform: translateX(-100px);
            }
        }

        @media (max-width: 850px) {
            #gameContainer {
                border-width: 2px;
                border-radius: 15px;
            }

            #ui {
                font-size: 24px;
                padding: 8px 15px;
                top: 10px;
                left: 10px;
            }

            #musicToggle {
                top: 10px;
                right: 10px;
            }

            #musicBtn {
                font-size: 16px;
                padding: 8px 12px;
                margin-top: -6px;
            }

            #instructions {
                font-size: 12px;
                padding: 6px 12px;
                bottom: 10px;
            }

            button {
                font-size: 16px;
                padding: 12px 25px;
            }

            #gameOver {
                padding: 30px;
            }

            #gameOver h2 {
                font-size: 24px;
            }
        }

        @media (max-width: 450px) {
            #ui {
                font-size: 20px;
                padding: 6px 12px;
            }

            #musicToggle {
                top: 10px;
            }

            #musicBtn {
                font-size: 14px;
                padding: 6px 10px;
                margin-top: -6px;
            }

            #instructions {
                font-size: 11px;
                padding: 5px 10px;
            }

            #gameOver {
                padding: 20px;
            }

            #gameOver h2 {
                font-size: 20px;
                margin: 10px 0;
            }

            button {
                font-size: 14px;
                padding: 10px 20px;
            }

            .circle {
                width: 150px;
                height: 150px;
            }

            .duck {
                width: 90px;
                height: 60px;
            }

            .title {
                font-size: 2.5rem;
                letter-spacing: 4px;
            }

            .subtitle {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
<!-- Splash Screen -->
<div id="splashScreen" class="splash-screen">
    <div class="clouds">
        <div class="cloud cloud1"></div>
        <div class="cloud cloud2"></div>
        <div class="cloud cloud3"></div>
    </div>

    <div class="splash-container">
        <div class="logo-container">
            <div class="circle">
                <div class="duck">
                    <div class="duck-eye"></div>
                    <div class="duck-wing">
                        <div class="wing-lines"></div>
                    </div>
                    <div class="duck-tail"></div>
                </div>
                <div class="underline"></div>
            </div>
        </div>

        <h1 class="title">ENTLINES</h1>
        <p class="subtitle">FLAPPY AVIATION</p>

        <div class="loading-container">
            <div class="loading-bar">
                <div class="loading-progress"></div>
            </div>
            <div class="loading-text">Preparing for takeoff...</div>
        </div>
    </div>
</div>

<div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <div id="ui">
        <div>Score: <span id="score">0</span></div>
    </div>

    <div id="musicToggle">
        <button id="musicBtn" onclick="toggleMusic()">ðŸ”‡ Musik</button>
    </div>

    <div id="instructions">
        <div id="startText">TOUCH oder SPACE zum Starten</div>
        <div id="playText" style="display: none;">TOUCH oder SPACE zum Fliegen</div>
    </div>

    <div id="gameOver">
        <h2>Game Over!</h2>
        <p>Score: <span id="finalScore">0</span></p>
        <button onclick="restartGame()">Nochmal spielen</button>
        <p style="font-size: 14px; color: #ccc; margin-top: 10px;">oder TOUCH/SPACE</p>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Responsive Canvas Sizing
    function resizeCanvas() {
        const container = document.getElementById('gameContainer');
        const isMobileDevice = window.innerWidth < 768;

        let maxWidth, maxHeight;

        if (isMobileDevice) {
            // Mobile: Use more screen space, especially in height
            maxWidth = window.innerWidth * 0.98;
            maxHeight = window.innerHeight * 0.98;
        } else {
            // Desktop: Keep original sizing
            maxWidth = window.innerWidth * 0.95;
            maxHeight = window.innerHeight * 0.95;
        }

        let width = 800;
        let height = 600;

        // Calculate scale to fit screen
        const scaleX = maxWidth / width;
        const scaleY = maxHeight / height;

        let scale;
        if (isMobileDevice) {
            // On mobile, prioritize height scaling for better screen usage
            scale = Math.min(scaleX, scaleY * 1.2, 1.5); // Allow up to 1.5x scaling on mobile
        } else {
            scale = Math.min(scaleX, scaleY, 1);
        }

        canvas.width = width * scale;
        canvas.height = height * scale;

        // Scale context for consistent gameplay
        ctx.scale(scale, scale);

        // Update game container size
        container.style.width = canvas.width + 'px';
        container.style.height = canvas.height + 'px';
    }

    // Call resize on window resize (not on load, handled by initGame)
    window.addEventListener('resize', resizeCanvas);

    // Spiel-Variablen
    let bird = {
        x: 100,
        y: 300,
        width: 30,
        height: 25,
        velocity: 0,
        gravity: 0.33,
        jump: -6.05,
        rotation: 0
    };

    let pipes = [];
    let score = 0;
    let gameRunning = true;
    let frameCount = 0;
    let gameStarted = false;
    let cloudOffset = 0;
    let parallaxOffset = 0;
    let particles = [];
    let scoreEffect = {show: false, scale: 1, opacity: 1};
    let stars = [];
    let raindrops = [];

    // Audio System fÃ¼r Learning to Fly Melodie
    let audioContext;
    let isAudioPlaying = false;
    let audioInterval;
    let currentChordIndex = 0;
    let currentStrumIndex = 0;
    let pitchVariation = 0;
    let musicEnabled = false; // Per default deaktiviert

    // Sterne generieren (weniger auf Mobile)
    const isMobile = window.innerWidth < 768;
    const starCount = isMobile ? 20 : 50;

    for (let i = 0; i < starCount; i++) {
        stars.push({
            x: Math.random() * 800,  // Use base width, not scaled
            y: Math.random() * 600 * 0.6,
            size: Math.random() * 2 + 0.5,
            twinkle: Math.random() * Math.PI * 2
        });
    }

    // Pipe-Einstellungen
    const pipeWidth = 60;
    const pipeGap = 160;
    const pipeSpeed = 2.2;

    // Learning to Fly Akkordfolge und Noten (hÃ¶here Oktave)
    const chordProgression = ['F', 'C', 'Am', 'G', 'F', 'C', 'Am', 'G'];
    const chordNotes = {
        'F': [349.23, 440.00, 523.25],   // F4, A4, C5
        'C': [523.25, 659.25, 783.99],   // C5, E5, G5
        'Am': [440.00, 523.25, 659.25],  // A4, C5, E5
        'G': [392.00, 493.88, 587.33]    // G4, B4, D5
    };
    const strummingPattern = ['â†“', 'â†“', 'â†‘', 'â†“', 'â†‘', 'â†“', 'â†‘', ''];

    // Event Listeners
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
            e.preventDefault();
            if (!gameRunning) {
                // Spiel ist vorbei - Neustart
                restartGame();
            } else {
                // Spiel lÃ¤uft - Springen
                jump();
            }
        }
    });

    canvas.addEventListener('click', jump);
    canvas.addEventListener('touchstart', handleTouch, {passive: true});
    canvas.addEventListener('touchend', handleTouch, {passive: true});

    // Global touch handler for background touches (mobile)
    document.addEventListener('touchstart', (e) => {
        // Only trigger if touch is outside game container and game is running
        const gameContainer = document.getElementById('gameContainer');
        const splashScreen = document.getElementById('splashScreen');
        const footer = document.querySelector('.footer');
        
        if (!gameContainer.contains(e.target) && !splashScreen.contains(e.target) && !footer.contains(e.target)) {
            // Blockiere Touch Events in den linken 30% wenn Autopilot aktiv ist (nur mobile)
            if (autopilotActive && window.innerWidth < 768) {
                const touchX = e.touches && e.touches[0] ? e.touches[0].clientX : e.clientX;
                const leftZoneWidth = window.innerWidth * 0.3;
                
                if (touchX < leftZoneWidth) {
                    return; // Ignoriere Touch in der linken Zone
                }
            }
            
            handleTouch(e);
        }
    }, {passive: true});

    // Prevent scrolling on mobile only on game container
    const gameContainer = document.getElementById('gameContainer');
    gameContainer.addEventListener('touchmove', (e) => {
        e.preventDefault();
    }, {passive: false});

    function jump() {
        if (!gameStarted) {
            gameStarted = true;
            if (musicEnabled) {
                startAudio(); // Musik beginnen wenn Spiel startet und aktiviert
            }
        }
        if (gameRunning) {
            bird.velocity = bird.jump;
            bird.rotation = -0.3;
        }
    }

    function handleTouch(e) {
        if (e.type === 'touchstart') {
            // Blockiere Touch Events in den linken 30% wenn Autopilot aktiv ist (nur mobile)
            if (autopilotActive && window.innerWidth < 768) {
                const touchX = e.touches && e.touches[0] ? e.touches[0].clientX : e.clientX;
                const leftZoneWidth = window.innerWidth * 0.3;
                
                if (touchX < leftZoneWidth) {
                    return; // Ignoriere Touch in der linken Zone
                }
            }
            
            // Don't preventDefault on passive listener
            if (!gameRunning && gameStarted) {
                restartGame();
            } else {
                jump();
            }
        }
    }

    // Audio System Funktionen
    function initAudio() {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
    }

    function startAudio() {
        if (!isAudioPlaying && musicEnabled) {
            initAudio();
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            isAudioPlaying = true;
            playNextChord();
            audioInterval = setInterval(() => {
                if (isAudioPlaying && gameRunning) {
                    playNextChord();
                }
            }, 400); // Etwa 150 BPM
        }
    }

    function stopAudio() {
        isAudioPlaying = false;
        if (audioInterval) {
            clearInterval(audioInterval);
            audioInterval = null;
        }
    }

    function playGuitarChord(chordName, strumDirection, pitchShift = 0) {
        if (!audioContext) return;

        const notes = chordNotes[chordName];
        const oscillators = [];

        notes.forEach((frequency, index) => {
            // TonhÃ¶hen-Variation anwenden
            const shiftedFrequency = frequency * (1 + pitchShift);

            // Leichte VerzÃ¶gerung fÃ¼r Strumming-Effekt
            const delay = strumDirection === 'â†“' ? index * 0.02 : (notes.length - index - 1) * 0.02;

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            // Filter fÃ¼r sanfteren Gitarren-Sound
            const filterNode = audioContext.createBiquadFilter();
            filterNode.type = 'lowpass';
            filterNode.frequency.value = 1500 + Math.sin(frameCount * 0.01) * 200;

            oscillator.connect(filterNode);
            filterNode.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.setValueAtTime(shiftedFrequency, audioContext.currentTime + delay);
            oscillator.type = 'sawtooth';

            // Sanftere Envelope
            gainNode.gain.setValueAtTime(0, audioContext.currentTime + delay);
            gainNode.gain.linearRampToValueAtTime(0.08, audioContext.currentTime + delay + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + delay + 1.2);

            oscillator.start(audioContext.currentTime + delay);
            oscillator.stop(audioContext.currentTime + delay + 1.5);

            oscillators.push(oscillator);
        });
    }

    function playNextChord() {
        if (!musicEnabled) return;

        const currentChord = chordProgression[currentChordIndex];
        const currentStrum = strummingPattern[currentStrumIndex];

        if (currentStrum) { // Nur wenn nicht leer
            // TonhÃ¶he basierend auf Vogel-Position (hÃ¶her = hÃ¶here Tonlage)
            const heightVariation = (600 - bird.y) / 600 * 0.15 - 0.075; // -0.075 bis +0.075

            // Geschwindigkeit basierend auf FlÃ¼gelschlag-Geschwindigkeit
            const flapSpeed = Math.abs(bird.velocity) * 0.02; // StÃ¤rkerer FlÃ¼gelschlag bei mehr Bewegung
            const scoreVariation = (score % 10) * 0.01;
            const randomVariation = (Math.random() - 0.5) * 0.01;

            pitchVariation = heightVariation + scoreVariation + randomVariation;

            playGuitarChord(currentChord, currentStrum, pitchVariation);
        }

        // Strumming-Geschwindigkeit anpassen basierend auf Vogel-Geschwindigkeit
        const baseInterval = 400;
        const speedFactor = Math.max(0.7, Math.min(1.3, 1 + bird.velocity * 0.02)); // 0.7x bis 1.3x Speed

        if (audioInterval) {
            clearInterval(audioInterval);
            audioInterval = setInterval(() => {
                if (isAudioPlaying && gameRunning && musicEnabled) {
                    playNextChord();
                }
            }, baseInterval / speedFactor);
        }

        // Zum nÃ¤chsten Strum
        currentStrumIndex = (currentStrumIndex + 1) % strummingPattern.length;


        // Akkordwechsel nach kompletter Pattern
        if (currentStrumIndex === 0) {
            currentChordIndex = (currentChordIndex + 1) % chordProgression.length;
        }
    }

    function toggleMusic() {
        musicEnabled = !musicEnabled;
        const musicBtn = document.getElementById('musicBtn');

        if (musicEnabled) {
            musicBtn.textContent = 'ðŸ”Š Musik';
            musicBtn.classList.add('enabled');
            if (gameStarted && gameRunning) {
                startAudio();
            }
        } else {
            musicBtn.textContent = 'ðŸ”‡ Musik';
            musicBtn.classList.remove('enabled');
            stopAudio();
        }
    }

    function createPipe() {
        const minHeight = 50;
        const maxHeight = 600 - pipeGap - minHeight;  // Use base height, not scaled
        const height = Math.random() * (maxHeight - minHeight) + minHeight;

        pipes.push({
            x: 800,  // Use base width, not scaled
            topHeight: height,
            bottomY: height + pipeGap,
            bottomHeight: 600 - (height + pipeGap),  // Use base height
            passed: false
        });
    }

    function updateBird() {
        if (gameStarted) {
            bird.velocity += bird.gravity;
            bird.y += bird.velocity;
            bird.rotation = Math.min(bird.velocity * 0.05, 0.5);
        } else {
            bird.y = 300 + Math.sin(frameCount * 0.05) * 10;
        }

        if (bird.y + bird.height > 600 || bird.y < 0) {  // Use base height
            gameOver();
        }
    }

    function updatePipes() {
        if (!gameStarted) return;

        if (frameCount % 140 === 0) {
            createPipe();
        }

        for (let i = pipes.length - 1; i >= 0; i--) {
            const pipe = pipes[i];
            pipe.x -= pipeSpeed;

            if (pipe.x + pipeWidth < 0) {
                pipes.splice(i, 1);
                continue;
            }

            if (!pipe.passed && pipe.x + pipeWidth < bird.x) {
                pipe.passed = true;
                score++;
                document.getElementById('score').textContent = score;
                triggerScoreEffect();
                createScoreParticles(bird.x, bird.y);
            }

            if (bird.x < pipe.x + pipeWidth &&
                bird.x + bird.width > pipe.x) {
                if (bird.y < pipe.topHeight ||
                    bird.y + bird.height > pipe.bottomY) {
                    gameOver();
                }
            }
        }
    }

    function drawBackground() {
        // Use base dimensions for all calculations
        const baseWidth = 800;
        const baseHeight = 600;
        const groundY = baseHeight - 60;

        // Ferne Berge mit seamless looping
        const mountainGradient = ctx.createLinearGradient(0, groundY - 140, 0, groundY);
        mountainGradient.addColorStop(0, '#9E9E9E');
        mountainGradient.addColorStop(0.6, '#757575');
        mountainGradient.addColorStop(1, '#616161');

        ctx.fillStyle = mountainGradient;
        const mountainSpacing = 150;
        const mountainCount = Math.ceil((baseWidth + 400) / mountainSpacing) + 2;

        for (let i = -2; i < mountainCount; i++) {
            let x = (i * mountainSpacing - (parallaxOffset * 0.2) % (mountainSpacing * 8)) % (mountainSpacing * 8);
            if (x < -200) x += mountainSpacing * 8;
            if (x > baseWidth + 200) x -= mountainSpacing * 8;

            const height = 120 + Math.sin(i * 0.7) * 50;
            drawSimpleMountain(x, groundY, 140, height);
        }

        // Mittlere Berge mit seamless looping
        const midMountainGradient = ctx.createLinearGradient(0, groundY - 90, 0, groundY);
        midMountainGradient.addColorStop(0, '#689F38');
        midMountainGradient.addColorStop(0.7, '#558B2F');
        midMountainGradient.addColorStop(1, '#33691E');

        ctx.fillStyle = midMountainGradient;
        const midMountainSpacing = 180;
        const midMountainCount = Math.ceil((baseWidth + 400) / midMountainSpacing) + 2;

        for (let i = -2; i < midMountainCount; i++) {
            let x = (i * midMountainSpacing - (parallaxOffset * 0.4) % (midMountainSpacing * 6)) % (midMountainSpacing * 6);
            if (x < -200) x += midMountainSpacing * 6;
            if (x > baseWidth + 200) x -= midMountainSpacing * 6;

            const height = 80 + Math.sin(i * 0.8) * 30;
            drawSimpleMountain(x, groundY, 160, height);
        }

        // Volumetrische Wolken mit perfektem seamless looping
        const cloudSpacing = 180;
        const cloudCount = Math.ceil((baseWidth + 400) / cloudSpacing) + 2;

        for (let i = -2; i < cloudCount; i++) {
            let x = (i * cloudSpacing - (cloudOffset * 0.8) % (cloudSpacing * 8)) % (cloudSpacing * 8);
            if (x < -200) x += cloudSpacing * 8;
            if (x > baseWidth + 200) x -= cloudSpacing * 8;

            const y = 40 + Math.sin(i * 0.6 + frameCount * 0.005) * 30;
            const opacity = 0.7 + Math.sin(frameCount * 0.008 + i) * 0.2;
            const scale = 0.8 + Math.sin(i * 0.4 + frameCount * 0.003) * 0.4;

            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            drawEnhancedCloud(x, y, scale);
        }

        // Texturierter Boden
        const groundGradient = ctx.createLinearGradient(0, groundY, 0, baseHeight);
        groundGradient.addColorStop(0, '#8D6E63');
        groundGradient.addColorStop(0.3, '#795548');
        groundGradient.addColorStop(1, '#5D4037');

        ctx.fillStyle = groundGradient;
        ctx.fillRect(0, groundY, baseWidth, 60);

        // Boden-Textur mit seamless pattern
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        const textureOffset = (parallaxOffset * 0.1) % 16;
        for (let x = -textureOffset; x < baseWidth + 16; x += 8) {
            const height = 2 + Math.sin(x * 0.1);
            ctx.fillRect(x, groundY + height, 4, 2);
        }

        // Lebendiges Gras mit seamless pattern
        const grassGradient = ctx.createLinearGradient(0, groundY, 0, groundY + 10);
        grassGradient.addColorStop(0, '#4CAF50');
        grassGradient.addColorStop(0.5, '#388E3C');
        grassGradient.addColorStop(1, '#2E7D32');

        ctx.fillStyle = grassGradient;
        const grassOffset = (parallaxOffset * 0.3) % 8;
        for (let x = -grassOffset; x < baseWidth + 8; x += 4) {
            const height = 10 + Math.sin(x * 0.12 + frameCount * 0.02) * 4;
            const sway = Math.sin(x * 0.05 + frameCount * 0.03);
            ctx.fillRect(x + sway, groundY, 3, -height);
        }

        // Detaillierte BÃ¤ume mit seamless looping
        const treeSpacing = 80;
        const treeCount = Math.ceil((baseWidth + 200) / treeSpacing) + 2;

        for (let i = -2; i < treeCount; i++) {
            let x = (i * treeSpacing + 40 - (parallaxOffset * 0.6) % (treeSpacing * 10)) % (treeSpacing * 10);
            if (x < -100) x += treeSpacing * 10;
            if (x > baseWidth + 100) x -= treeSpacing * 10;

            const treeHeight = 1 + Math.sin(i * 0.4) * 0.3;
            drawDetailedTree(x, groundY, treeHeight);
        }
    }

    function drawSimpleMountain(x, groundY, width, height) {
        ctx.save();
        
        // UnregelmÃ¤ÃŸige, realistische Berg-Silhouette
        ctx.beginPath();
        ctx.moveTo(x - width * 0.1, groundY);
        
        // Linke Seite mit natÃ¼rlichen Kurven
        ctx.quadraticCurveTo(x + width * 0.05, groundY - height * 0.3, x + width * 0.15, groundY - height * 0.45);
        ctx.quadraticCurveTo(x + width * 0.22, groundY - height * 0.55, x + width * 0.3, groundY - height * 0.65);
        ctx.lineTo(x + width * 0.35, groundY - height * 0.75);
        ctx.quadraticCurveTo(x + width * 0.4, groundY - height * 0.82, x + width * 0.45, groundY - height * 0.88);
        
        // Hauptgipfel mit gezackter Spitze
        ctx.lineTo(x + width * 0.48, groundY - height * 0.92);
        ctx.lineTo(x + width * 0.52, groundY - height * 0.98);
        ctx.lineTo(x + width * 0.55, groundY - height);
        ctx.lineTo(x + width * 0.58, groundY - height * 0.97);
        ctx.lineTo(x + width * 0.62, groundY - height * 0.94);
        
        // Rechte Seite mit FelsvorsprÃ¼ngen
        ctx.lineTo(x + width * 0.68, groundY - height * 0.85);
        ctx.quadraticCurveTo(x + width * 0.72, groundY - height * 0.78, x + width * 0.75, groundY - height * 0.7);
        ctx.lineTo(x + width * 0.78, groundY - height * 0.68);
        ctx.quadraticCurveTo(x + width * 0.82, groundY - height * 0.6, x + width * 0.85, groundY - height * 0.5);
        ctx.quadraticCurveTo(x + width * 0.92, groundY - height * 0.3, x + width * 0.98, groundY - height * 0.15);
        ctx.lineTo(x + width * 1.1, groundY);
        ctx.closePath();
        ctx.fill();
        
        // Mehrschichtige Schneefelder
        if (height > 90) {
            // HauptschneeflÃ¤che
            ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
            ctx.beginPath();
            ctx.moveTo(x + width * 0.42, groundY - height * 0.8);
            ctx.quadraticCurveTo(x + width * 0.5, groundY - height * 0.88, x + width * 0.58, groundY - height * 0.82);
            ctx.lineTo(x + width * 0.62, groundY - height * 0.85);
            ctx.quadraticCurveTo(x + width * 0.55, groundY - height * 0.92, x + width * 0.48, groundY - height * 0.85);
            ctx.closePath();
            ctx.fill();
            
            // Gipfelschnee
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.beginPath();
            ctx.moveTo(x + width * 0.52, groundY - height * 0.98);
            ctx.lineTo(x + width * 0.55, groundY - height);
            ctx.lineTo(x + width * 0.58, groundY - height * 0.97);
            ctx.lineTo(x + width * 0.56, groundY - height * 0.94);
            ctx.lineTo(x + width * 0.54, groundY - height * 0.95);
            ctx.closePath();
            ctx.fill();
            
            // Schneeverwehungen
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(x + width * 0.65, groundY - height * 0.75, 8, 0, Math.PI * 2);
            ctx.arc(x + width * 0.45, groundY - height * 0.7, 6, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Felsschatten fÃ¼r mehr Tiefe
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.beginPath();
        ctx.moveTo(x + width * 0.55, groundY - height);
        ctx.lineTo(x + width * 0.62, groundY - height * 0.94);
        ctx.quadraticCurveTo(x + width * 0.65, groundY - height * 0.8, x + width * 0.7, groundY - height * 0.65);
        ctx.lineTo(x + width * 0.65, groundY - height * 0.7);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
    }


    function drawEnhancedCloud(x, y, scale) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(scale, scale);

        // VollstÃ¤ndig gefÃ¼llte Wolke ohne LÃ¶cher
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        
        // Erstelle eine zusammenhÃ¤ngende Wolkenform
        ctx.beginPath();
        // Linke Seite
        ctx.arc(-10, 5, 20, Math.PI * 0.5, Math.PI * 1.5);
        // Obere Kurven
        ctx.arc(5, -8, 15, Math.PI, Math.PI * 2);
        ctx.arc(25, -12, 18, Math.PI, Math.PI * 2);
        ctx.arc(45, -8, 15, Math.PI, Math.PI * 2);
        // Rechte Seite
        ctx.arc(55, 5, 20, Math.PI * 1.5, Math.PI * 0.5);
        // Untere Verbindung
        ctx.arc(25, 15, 35, 0, Math.PI);
        ctx.closePath();
        ctx.fill();

        // Schatten fÃ¼r Tiefe
        ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
        ctx.beginPath();
        ctx.arc(2, 8, 18, 0, Math.PI);
        ctx.arc(25, 8, 30, 0, Math.PI);
        ctx.arc(48, 8, 18, 0, Math.PI);
        ctx.fill();

        // GlÃ¤nzende Highlights
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.beginPath();
        ctx.arc(-5, -5, 8, 0, Math.PI * 2);
        ctx.arc(15, -15, 10, 0, Math.PI * 2);
        ctx.arc(35, -15, 8, 0, Math.PI * 2);
        ctx.arc(50, -5, 6, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    function drawDetailedTree(x, groundY, scale) {
        ctx.save();
        ctx.translate(x, groundY);
        ctx.scale(scale, scale);

        // Baumstamm mit leichter VerjÃ¼ngung
        const trunkGradient = ctx.createLinearGradient(-4, 0, 4, 0);
        trunkGradient.addColorStop(0, '#8B6F47');
        trunkGradient.addColorStop(0.5, '#6D4C41');
        trunkGradient.addColorStop(1, '#5D4037');

        ctx.fillStyle = trunkGradient;
        ctx.beginPath();
        ctx.moveTo(-4, 0);
        ctx.lineTo(-3, -20);
        ctx.lineTo(-2, -30);
        ctx.lineTo(2, -30);
        ctx.lineTo(3, -20);
        ctx.lineTo(4, 0);
        ctx.closePath();
        ctx.fill();

        // Einfache Rindentextur
        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-2, -5);
        ctx.lineTo(2, -5);
        ctx.moveTo(-2, -12);
        ctx.lineTo(2, -12);
        ctx.moveTo(-1, -19);
        ctx.lineTo(1, -19);
        ctx.stroke();

        // Baumkrone mit mehreren Ã¼berlappenden Kreisen (wie im Bild)
        // DunkelgrÃ¼ne Basis
        ctx.fillStyle = '#2E7D32';
        ctx.beginPath();
        ctx.arc(-8, -35, 12, 0, Math.PI * 2);
        ctx.arc(8, -35, 12, 0, Math.PI * 2);
        ctx.arc(0, -40, 14, 0, Math.PI * 2);
        ctx.fill();

        // Mittlere grÃ¼ne Schicht
        ctx.fillStyle = '#43A047';
        ctx.beginPath();
        ctx.arc(-6, -38, 10, 0, Math.PI * 2);
        ctx.arc(6, -38, 10, 0, Math.PI * 2);
        ctx.arc(0, -45, 12, 0, Math.PI * 2);
        ctx.fill();

        // HellgrÃ¼ne Highlights
        ctx.fillStyle = '#66BB6A';
        ctx.beginPath();
        ctx.arc(-4, -42, 8, 0, Math.PI * 2);
        ctx.arc(4, -42, 8, 0, Math.PI * 2);
        ctx.arc(0, -48, 10, 0, Math.PI * 2);
        ctx.fill();

        // Oberste hellste Schicht
        ctx.fillStyle = '#81C784';
        ctx.beginPath();
        ctx.arc(0, -50, 7, 0, Math.PI * 2);
        ctx.arc(-3, -46, 5, 0, Math.PI * 2);
        ctx.arc(3, -46, 5, 0, Math.PI * 2);
        ctx.fill();

        // Kleine Details fÃ¼r natÃ¼rlicheren Look
        ctx.fillStyle = '#A5D6A7';
        ctx.beginPath();
        ctx.arc(-7, -45, 3, 0, Math.PI * 2);
        ctx.arc(7, -45, 3, 0, Math.PI * 2);
        ctx.arc(0, -52, 4, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    function drawStars() {
        ctx.save();
        for (let star of stars) {
            const twinkle = Math.sin(frameCount * 0.02 + star.twinkle) * 0.5 + 0.5;
            const alpha = 0.3 + twinkle * 0.7;

            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
            ctx.fill();

            // Stern-Strahlen
            if (twinkle > 0.7) {
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(star.x - star.size * 2, star.y);
                ctx.lineTo(star.x + star.size * 2, star.y);
                ctx.moveTo(star.x, star.y - star.size * 2);
                ctx.lineTo(star.x, star.y + star.size * 2);
                ctx.stroke();
            }
        }
        ctx.restore();
    }

    function drawRainEffect() {
        // Gelegentlicher Regen-Effekt (weniger auf Mobile)
        const maxRaindrops = isMobile ? 10 : 20;
        const rainChance = isMobile ? 0.002 : 0.003;

        if (Math.random() < rainChance && raindrops.length < maxRaindrops) {
            raindrops.push({
                x: Math.random() * 800,  // Use base width
                y: -10,
                speed: Math.random() * 3 + 2,
                length: Math.random() * 10 + 5
            });
        }

        ctx.save();
        ctx.strokeStyle = 'rgba(173, 216, 230, 0.6)';
        ctx.lineWidth = 1;

        for (let i = raindrops.length - 1; i >= 0; i--) {
            const drop = raindrops[i];

            ctx.beginPath();
            ctx.moveTo(drop.x, drop.y);
            ctx.lineTo(drop.x - 2, drop.y + drop.length);
            ctx.stroke();

            drop.y += drop.speed;
            drop.x -= 0.5;

            if (drop.y > canvas.height) {
                raindrops.splice(i, 1);
            }
        }
        ctx.restore();
    }

    function createScoreParticles(x, y) {
        for (let i = 0; i < 8; i++) {
            particles.push({
                x: x + Math.random() * 40 - 20,
                y: y + Math.random() * 20 - 10,
                vx: (Math.random() - 0.5) * 4,
                vy: Math.random() * -3 - 1,
                life: 1,
                decay: 0.02,
                color: `hsl(${Math.random() * 60 + 30}, 100%, 60%)`
            });
        }
    }

    function drawParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];

            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.1;
            p.life -= p.decay;

            if (p.life <= 0) {
                particles.splice(i, 1);
                continue;
            }

            ctx.save();
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 3 * p.life, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    }

    function triggerScoreEffect() {
        scoreEffect.show = true;
        scoreEffect.scale = 1.5;
        scoreEffect.opacity = 1;
    }

    function drawScoreEffect() {
        if (scoreEffect.show) {
            scoreEffect.scale += (1 - scoreEffect.scale) * 0.1;
            scoreEffect.opacity -= 0.02;

            if (scoreEffect.opacity <= 0) {
                scoreEffect.show = false;
                scoreEffect.scale = 1;
                scoreEffect.opacity = 1;
            }

            ctx.save();
            ctx.globalAlpha = scoreEffect.opacity;
            ctx.fillStyle = '#FFD700';
            ctx.font = `bold ${24 * scoreEffect.scale}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('+1', canvas.width / 2, 100);
            ctx.restore();
        }
    }


    function drawBird() {
        ctx.save();

        const centerX = bird.x + bird.width / 2;
        const centerY = bird.y + bird.height / 2;

        ctx.translate(centerX, centerY);
        ctx.rotate(bird.rotation);

        const wingFlap = Math.sin(frameCount * 0.3) * 0.5;

        // Schatten
        ctx.shadowColor = 'rgba(0,0,0,0.3)';
        ctx.shadowBlur = 6;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;

        // Enten-KÃ¶rper - ovaler als rund
        ctx.fillStyle = '#FFDC00';
        ctx.beginPath();
        ctx.ellipse(0, 0, bird.width / 2, bird.height / 2.2, 0, 0, Math.PI * 2);
        ctx.fill();

        // Enten-Bauch - weiÃŸ und grÃ¶ÃŸer
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.ellipse(3, 3, bird.width / 2.5, bird.height / 3, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowColor = 'transparent';

        // Enten-FlÃ¼gel - breiter und flacher
        ctx.fillStyle = '#FFA500';
        ctx.beginPath();
        ctx.ellipse(-6, wingFlap - 1, 14, 6, -0.2 + wingFlap * 0.1, 0, Math.PI * 2);
        ctx.fill();

        // FlÃ¼gel-Details
        ctx.fillStyle = '#FF8C00';
        ctx.beginPath();
        ctx.ellipse(-6, wingFlap - 1, 10, 3, -0.2 + wingFlap * 0.1, 0, Math.PI * 2);
        ctx.fill();

        // Enten-Kopf - runder
        ctx.fillStyle = '#FFDC00';
        ctx.beginPath();
        ctx.arc(6, -6, 8, 0, Math.PI * 2);
        ctx.fill();

        // Auge - Enten-typisch
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(8, -8, 5, 0, Math.PI * 2);
        ctx.fill();

        // Pupille
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(9, -7, 3, 0, Math.PI * 2);
        ctx.fill();

        // Augen-Glanz
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(10, -8, 1, 0, Math.PI * 2);
        ctx.fill();

        // Enten-Schnabel - breiter und flacher
        ctx.fillStyle = '#FFA500';
        ctx.beginPath();
        ctx.ellipse(bird.width / 2 + 6, -2, 8, 4, 0, 0, Math.PI * 2);
        ctx.fill();

        // Schnabel-Linie
        ctx.strokeStyle = '#FF8C00';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(bird.width / 2 + 2, -2);
        ctx.lineTo(bird.width / 2 + 10, -2);
        ctx.stroke();

        // NasenlÃ¶cher
        ctx.fillStyle = '#CC7000';
        ctx.beginPath();
        ctx.arc(bird.width / 2 + 8, -3, 0.8, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(bird.width / 2 + 10, -3, 0.8, 0, Math.PI * 2);
        ctx.fill();

        // Enten-Hals - lÃ¤nger
        ctx.fillStyle = '#FFDC00';
        ctx.beginPath();
        ctx.ellipse(4, -2, 4, 6, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    function drawPipes() {
        pipes.forEach(pipe => {
            // Dramatischer Schatten mit Blur-Effekt
            ctx.save();
            ctx.shadowColor = 'rgba(0,0,0,0.4)';
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 6;
            ctx.shadowOffsetY = 6;

            // HauptrÃ¶hre mit Premium 3D-Gradient
            const mainGradient = ctx.createLinearGradient(pipe.x, 0, pipe.x + pipeWidth, 0);
            mainGradient.addColorStop(0, '#66BB6A');
            mainGradient.addColorStop(0.2, '#4CAF50');
            mainGradient.addColorStop(0.5, '#388E3C');
            mainGradient.addColorStop(0.8, '#2E7D32');
            mainGradient.addColorStop(1, '#1B5E20');

            ctx.fillStyle = mainGradient;
            ctx.fillRect(pipe.x, 0, pipeWidth, pipe.topHeight);
            ctx.fillRect(pipe.x, pipe.bottomY, pipeWidth, pipe.bottomHeight);

            ctx.shadowColor = 'transparent';

            // Premium Metallische Caps
            const capGradient = ctx.createRadialGradient(
                pipe.x + pipeWidth / 2, pipe.topHeight - 15, 0,
                pipe.x + pipeWidth / 2, pipe.topHeight - 15, pipeWidth
            );
            capGradient.addColorStop(0, '#A5D6A7');
            capGradient.addColorStop(0.6, '#81C784');
            capGradient.addColorStop(1, '#66BB6A');

            ctx.fillStyle = capGradient;

            // Obere Cap mit Premium-Rundung
            ctx.beginPath();
            ctx.roundRect(pipe.x - 10, pipe.topHeight - 35, pipeWidth + 20, 35, [0, 0, 12, 12]);
            ctx.fill();

            // Untere Cap
            ctx.beginPath();
            ctx.roundRect(pipe.x - 10, pipe.bottomY, pipeWidth + 20, 35, [12, 12, 0, 0]);
            ctx.fill();

            // Premium 3D Highlights
            const highlightGradient = ctx.createLinearGradient(pipe.x, 0, pipe.x + 15, 0);
            highlightGradient.addColorStop(0, 'rgba(255,255,255,0.6)');
            highlightGradient.addColorStop(1, 'rgba(255,255,255,0.1)');

            ctx.fillStyle = highlightGradient;
            ctx.fillRect(pipe.x + 3, 0, 12, pipe.topHeight);
            ctx.fillRect(pipe.x + 3, pipe.bottomY, 12, pipe.bottomHeight);

            // Rechter Schatten fÃ¼r Tiefe
            const shadowGradient = ctx.createLinearGradient(pipe.x + pipeWidth - 10, 0, pipe.x + pipeWidth, 0);
            shadowGradient.addColorStop(0, 'rgba(0,0,0,0.1)');
            shadowGradient.addColorStop(1, 'rgba(0,0,0,0.3)');

            ctx.fillStyle = shadowGradient;
            ctx.fillRect(pipe.x + pipeWidth - 10, 0, 10, pipe.topHeight);
            ctx.fillRect(pipe.x + pipeWidth - 10, pipe.bottomY, 10, pipe.bottomHeight);

            // Cap-Highlights mit Glow
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.fillRect(pipe.x - 8, pipe.topHeight - 32, pipeWidth + 16, 4);
            ctx.fillRect(pipe.x - 8, pipe.bottomY + 3, pipeWidth + 16, 4);

            // Realistische Metallnieten
            ctx.fillStyle = '#4CAF50';
            for (let i = 0; i < 4; i++) {
                const y1 = (pipe.topHeight / 4) * i + 20;
                const y2 = pipe.bottomY + (pipe.bottomHeight / 4) * i + 10;

                ctx.beginPath();
                ctx.arc(pipe.x + pipeWidth / 2, y1, 2, 0, Math.PI * 2);
                ctx.fill();

                if (y2 < 600 - 10) {  // Use base height
                    ctx.beginPath();
                    ctx.arc(pipe.x + pipeWidth / 2, y2, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            ctx.restore();
        });
    }

    function draw() {
        ctx.clearRect(0, 0, 800, 600);  // Clear base dimensions

        if (gameStarted) {
            cloudOffset += 0.5;
            parallaxOffset += 1;
        }

        drawStars();
        drawBackground();
        drawParticles();
        drawPipes();
        drawBird();
        drawScoreEffect();
        drawRainEffect();
    }

    function gameLoop() {
        if (!gameRunning) return;

        frameCount++;
        updateBird();
        updatePipes();
        draw();

        if (gameStarted) {
            document.getElementById('startText').style.display = 'none';
            document.getElementById('playText').style.display = 'block';
        }

        requestAnimationFrame(gameLoop);
    }

    function gameOver() {
        gameRunning = false;
        stopAudio(); // Musik stoppen bei Game Over
        
        // Auto-Pilot bei Game Over deaktivieren
        if (autopilotActive) {
            stopHiddenAutopilot();
        }
        
        document.getElementById('finalScore').textContent = score;
        document.getElementById('gameOver').style.display = 'block';
    }

    function restartGame() {
        bird.y = 300;
        bird.velocity = 0;
        bird.rotation = 0;
        pipes = [];
        score = 0;
        frameCount = 0;
        gameRunning = true;
        gameStarted = false;
        cloudOffset = 0;
        parallaxOffset = 0;
        particles = [];
        scoreEffect = {show: false, scale: 1, opacity: 1};
        raindrops = [];

        // Audio stoppen und zurÃ¼cksetzen
        stopAudio();
        currentChordIndex = 0;
        currentStrumIndex = 0;
        pitchVariation = 0;

        document.getElementById('score').textContent = '0';
        document.getElementById('gameOver').style.display = 'none';
        document.getElementById('startText').style.display = 'block';
        document.getElementById('playText').style.display = 'none';

        gameLoop();
    }

    // Splash Screen Logic
    let splashShown = false;

    function initGame() {
        // Always show splash screen on page load/reload
        showSplashScreen();
    }

    function showSplashScreen() {
        const splashScreen = document.getElementById('splashScreen');
        splashShown = true;

        // Auto-hide after animation (5.5 seconds)
        setTimeout(() => {
            if (splashShown) {
                hideSplashScreen();
                startGame();
            }
        }, 5500);

        // Click/Touch to skip
        splashScreen.addEventListener('click', () => {
            if (splashShown) {
                hideSplashScreen();
                startGame();
            }
        });

        splashScreen.addEventListener('touchstart', () => {
            if (splashShown) {
                hideSplashScreen();
                startGame();
            }
        });
    }

    function hideSplashScreen() {
        const splashScreen = document.getElementById('splashScreen');
        splashScreen.classList.add('hidden');
        splashShown = false;

        setTimeout(() => {
            splashScreen.style.display = 'none';
        }, 500);
    }

    function startGame() {
        // Initialize canvas and start game loop
        resizeCanvas();
        gameLoop();
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', initGame);

    // Hidden Auto-Pilot System
    let autopilotActive = false;
    let autopilotInterval = null;
    let heartPressTimer = null;
    let heartPressStart = 0;

    function autopilotLogic() {
        if (!autopilotActive || !gameRunning) return;
        
        const birdY = bird.y;
        const birdVelocity = bird.velocity;
        
        // Absolute Grenzen
        if (birdY < 5) return; // Lass fallen
        if (birdY > 580) { jump(); return; }
        
        // Finde aktuelle RÃ¶hre
        let currentPipe = null;
        let minDistance = Infinity;
        
        for (let pipe of pipes) {
            const distance = Math.abs(pipe.x + 30 - bird.x);
            if (distance < minDistance && pipe.x + 60 > bird.x) {
                minDistance = distance;
                currentPipe = pipe;
            }
        }
        
        if (!currentPipe) {
            if (birdY > 320 && birdVelocity > 0) jump();
            return;
        }
        
        const gapTop = currentPipe.topHeight;
        const gapBottom = currentPipe.topHeight + 180;
        const gapMiddle = gapTop + 90;
        const distanceToPipe = currentPipe.x - bird.x;
        
        // Verhindere obere Kollisionen
        if (birdY < gapTop + 35) return;
        
        if (distanceToPipe > 100) {
            const targetHeight = 280;
            if (birdY > targetHeight + 40 && birdVelocity > 0) jump();
        } else if (distanceToPipe > 20) {
            const targetHeight = gapMiddle + 5;
            if (birdY > targetHeight && birdVelocity > 1) jump();
            if (birdVelocity > 3.5 && birdY > targetHeight - 20) jump();
            if (birdY + 25 > gapBottom - 40) jump();
        } else {
            const targetHeight = gapMiddle + 10;
            if (birdY + 25 > gapBottom - 50) { jump(); return; }
            if (birdY > targetHeight && birdVelocity > 0.5) jump();
            if (birdVelocity > 2.5 && birdY > gapMiddle - 5) jump();
            if (birdVelocity > 1.5 && birdY > gapMiddle + 20) jump();
        }
    }

    function startHiddenAutopilot() {
        autopilotActive = true;
        if (!gameStarted) jump();
        autopilotInterval = setInterval(autopilotLogic, 25);
    }

    function stopHiddenAutopilot() {
        autopilotActive = false;
        if (autopilotInterval) {
            clearInterval(autopilotInterval);
            autopilotInterval = null;
        }
    }

    // Heart press detection
    document.addEventListener('DOMContentLoaded', function() {
        const footer = document.querySelector('.footer');
        
        footer.addEventListener('mousedown', function(e) {
            if (e.target.textContent.includes('â¤ï¸')) {
                heartPressStart = Date.now();
                heartPressTimer = setTimeout(() => {
                    if (!autopilotActive) {
                        startHiddenAutopilot();
                    }
                }, 2000);
            }
        });
        
        footer.addEventListener('mouseup', function(e) {
            if (e.target.textContent.includes('â¤ï¸')) {
                const pressDuration = Date.now() - heartPressStart;
                
                if (heartPressTimer) {
                    clearTimeout(heartPressTimer);
                    heartPressTimer = null;
                }
                
                // Kurzer Klick bei aktivem Autopilot = stoppen
                if (autopilotActive && pressDuration < 500) {
                    stopHiddenAutopilot();
                }
            }
        });
        
        // Touch support fÃ¼r mobile
        footer.addEventListener('touchstart', function(e) {
            if (e.target.textContent.includes('â¤ï¸')) {
                heartPressStart = Date.now();
                heartPressTimer = setTimeout(() => {
                    if (!autopilotActive) {
                        startHiddenAutopilot();
                    }
                }, 2000);
            }
        });
        
        footer.addEventListener('touchend', function(e) {
            if (e.target.textContent.includes('â¤ï¸')) {
                const pressDuration = Date.now() - heartPressStart;
                
                if (heartPressTimer) {
                    clearTimeout(heartPressTimer);
                    heartPressTimer = null;
                }
                
                if (autopilotActive && pressDuration < 500) {
                    stopHiddenAutopilot();
                }
            }
        });
    });
    
    // Service Worker Registration
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', function() {
            navigator.serviceWorker.register('sw.js').then(function(registration) {
                console.log('ServiceWorker registration successful with scope: ', registration.scope);
            }, function(err) {
                console.log('ServiceWorker registration failed: ', err);
            });
        });
    }
</script>

<div class="footer">Made with â¤ï¸  by Martin Pfeffer</div>

</body>
</html>